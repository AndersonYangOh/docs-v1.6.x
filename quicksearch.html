<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"lib_contacts_address-port-contact.js.html":{"id":"lib_contacts_address-port-contact.js.html","title":"Source: lib/contacts/address-port-contact.js","body":" KadTools Modules kadkad/constantskad/contactskad/hookskad/storagekad/transportskad/utils Classes AddressPortContactBucketContactHTTPTransportItemLoggerMessagekad/storage.FSkad/storage.LocalStoragekad/storage.MemStoreNodeRouterRPCTCPTransportUDPTransport Events HTTPTransport#event:CONTACT_SEENHTTPTransport#event:FIND_NODEHTTPTransport#event:FIND_VALUEHTTPTransport#event:MESSAGE_DROPHTTPTransport#event:PINGHTTPTransport#event:readyHTTPTransport#event:STOREHTTPTransport#event:TIMEOUTNode#event:connectNode#event:disconnectNode#event:errorNode#event:joinNode#event:leaveRouter#event:addRouter#event:dropRouter#event:shiftRPC#event:CONTACT_SEENRPC#event:FIND_NODERPC#event:FIND_VALUERPC#event:MESSAGE_DROPRPC#event:PINGRPC#event:readyRPC#event:STORERPC#event:TIMEOUTTCPTransport#event:CONTACT_SEENTCPTransport#event:FIND_NODETCPTransport#event:FIND_VALUETCPTransport#event:MESSAGE_DROPTCPTransport#event:PINGTCPTransport#event:readyTCPTransport#event:STORETCPTransport#event:TIMEOUTUDPTransport#event:CONTACT_SEENUDPTransport#event:FIND_NODEUDPTransport#event:FIND_VALUEUDPTransport#event:MESSAGE_DROPUDPTransport#event:PINGUDPTransport#event:readyUDPTransport#event:STOREUDPTransport#event:TIMEOUT Tutorials Custom ContactsCustom Storage AdaptersCustom Transport AdaptersProtocol SpecificationUsing Hooks Externals kad-fskad-localstoragekad-memstore Source: lib/contacts/address-port-contact.js 'use strict'; var assert = require('assert'); var Contact = require('../contact'); var inherits = require('util').inherits; var utils = require('../utils'); /** * Represent a contact (or peer) * @constructor * @extends {Contact} * @param {Object} options * @param {String} options.address - IP or hostname * @param {Number} options.port - Listening port */ function AddressPortContact(options) { if (!(this instanceof AddressPortContact)) { return new AddressPortContact(options); } assert(typeof options === 'object', 'Invalid options were supplied'); assert(typeof options.address === 'string', 'Invalid address was supplied'); assert(typeof options.port === 'number', 'Invalid port was supplied'); this.address = options.address; this.port = options.port; Contact.call(this, options); } inherits(AddressPortContact, Contact); /** * Generate a NodeID by taking the SHA1 hash of the address and port * @private */ AddressPortContact.prototype._createNodeID = function() { return utils.createID(this.toString()); }; /** * Ensures that the address and port are valid * @returns {Boolean} */ AddressPortContact.prototype.valid = function() { return this.port &gt; 0 &amp;&amp; this.port &lt; 65536; }; /** * Generate a user-friendly string for the contact */ AddressPortContact.prototype.toString = function() { return this.address + ':' + this.port; }; module.exports = AddressPortContact; × Search results Close Documentation generated by JSDoc 3.4.3 using the DocStrap template. "},"lib_contact.js.html":{"id":"lib_contact.js.html","title":"Source: lib/contact.js","body":" KadTools Modules kadkad/constantskad/contactskad/hookskad/storagekad/transportskad/utils Classes AddressPortContactBucketContactHTTPTransportItemLoggerMessagekad/storage.FSkad/storage.LocalStoragekad/storage.MemStoreNodeRouterRPCTCPTransportUDPTransport Events HTTPTransport#event:CONTACT_SEENHTTPTransport#event:FIND_NODEHTTPTransport#event:FIND_VALUEHTTPTransport#event:MESSAGE_DROPHTTPTransport#event:PINGHTTPTransport#event:readyHTTPTransport#event:STOREHTTPTransport#event:TIMEOUTNode#event:connectNode#event:disconnectNode#event:errorNode#event:joinNode#event:leaveRouter#event:addRouter#event:dropRouter#event:shiftRPC#event:CONTACT_SEENRPC#event:FIND_NODERPC#event:FIND_VALUERPC#event:MESSAGE_DROPRPC#event:PINGRPC#event:readyRPC#event:STORERPC#event:TIMEOUTTCPTransport#event:CONTACT_SEENTCPTransport#event:FIND_NODETCPTransport#event:FIND_VALUETCPTransport#event:MESSAGE_DROPTCPTransport#event:PINGTCPTransport#event:readyTCPTransport#event:STORETCPTransport#event:TIMEOUTUDPTransport#event:CONTACT_SEENUDPTransport#event:FIND_NODEUDPTransport#event:FIND_VALUEUDPTransport#event:MESSAGE_DROPUDPTransport#event:PINGUDPTransport#event:readyUDPTransport#event:STOREUDPTransport#event:TIMEOUT Tutorials Custom ContactsCustom Storage AdaptersCustom Transport AdaptersProtocol SpecificationUsing Hooks Externals kad-fskad-localstoragekad-memstore Source: lib/contact.js 'use strict'; var assert = require('assert'); var utils = require('./utils'); /** * The base class from which custom contacts inherit; used by the included * {@link AddressPortContact}. Nodes provide each other with contact * information which indicates how others should communicate with them. * @constructor * @param {Object} options * @param {String} options.nodeID - Optional known 160 bit node ID */ function Contact(options) { if (!(this instanceof Contact)) { return new Contact(options); } assert(options instanceof Object, 'Invalid options were supplied'); Object.defineProperty(this, 'nodeID', { value: options.nodeID || this._createNodeID(), configurable: false, enumerable: true }); assert(utils.isValidKey(this.nodeID), 'Invalid nodeID was supplied'); if (options.lastSeen) { this.lastSeen = options.lastSeen; } else { this.lastSeen = Date.now(); } } /** * Updates the lastSeen property to right now */ Contact.prototype.seen = function() { this.lastSeen = Date.now(); }; /** * Validator function for determining if contact is okay * @abstract * @returns {Boolean} */ Contact.prototype.valid = function() { return true; }; /** * Unimplemented stub, called when no nodeID is passed to constructor. * @private * @abstract */ Contact.prototype._createNodeID = function() { throw new Error('Method not implemented'); }; module.exports = Contact; × Search results Close Documentation generated by JSDoc 3.4.3 using the DocStrap template. "},"lib_bucket.js.html":{"id":"lib_bucket.js.html","title":"Source: lib/bucket.js","body":" KadTools Modules kadkad/constantskad/contactskad/hookskad/storagekad/transportskad/utils Classes AddressPortContactBucketContactHTTPTransportItemLoggerMessagekad/storage.FSkad/storage.LocalStoragekad/storage.MemStoreNodeRouterRPCTCPTransportUDPTransport Events HTTPTransport#event:CONTACT_SEENHTTPTransport#event:FIND_NODEHTTPTransport#event:FIND_VALUEHTTPTransport#event:MESSAGE_DROPHTTPTransport#event:PINGHTTPTransport#event:readyHTTPTransport#event:STOREHTTPTransport#event:TIMEOUTNode#event:connectNode#event:disconnectNode#event:errorNode#event:joinNode#event:leaveRouter#event:addRouter#event:dropRouter#event:shiftRPC#event:CONTACT_SEENRPC#event:FIND_NODERPC#event:FIND_VALUERPC#event:MESSAGE_DROPRPC#event:PINGRPC#event:readyRPC#event:STORERPC#event:TIMEOUTTCPTransport#event:CONTACT_SEENTCPTransport#event:FIND_NODETCPTransport#event:FIND_VALUETCPTransport#event:MESSAGE_DROPTCPTransport#event:PINGTCPTransport#event:readyTCPTransport#event:STORETCPTransport#event:TIMEOUTUDPTransport#event:CONTACT_SEENUDPTransport#event:FIND_NODEUDPTransport#event:FIND_VALUEUDPTransport#event:MESSAGE_DROPUDPTransport#event:PINGUDPTransport#event:readyUDPTransport#event:STOREUDPTransport#event:TIMEOUT Tutorials Custom ContactsCustom Storage AdaptersCustom Transport AdaptersProtocol SpecificationUsing Hooks Externals kad-fskad-localstoragekad-memstore Source: lib/bucket.js 'use strict'; var _ = require('lodash'); var assert = require('assert'); var constants = require('./constants'); var Contact = require('./contact'); /** * A bucket is a &quot;column&quot; of the routing table. It is an array-like object that * holds {@link Contact}s. * @constructor */ function Bucket() { if (!(this instanceof Bucket)) { return new Bucket(); } this._contacts = []; } /** * Return the number of contacts in this bucket * @returns {Number} */ Bucket.prototype.getSize = function() { return this._contacts.length; }; /** * Return the list of contacts in this bucket * @returns {Array} */ Bucket.prototype.getContactList = function() { return _.clone(this._contacts); }; /** * Return the contact at the given index * @param {Number} index - Index of contact in bucket * @returns {Contact|null} */ Bucket.prototype.getContact = function(index) { assert(index &gt;= 0, 'Contact index cannot be negative'); return this._contacts[index] || null; }; /** * Adds the contact to the bucket * @param {Contact} contact - Contact instance to add to bucket * @returns {Boolean} added - Indicates whether or not the contact was added */ Bucket.prototype.addContact = function(contact) { assert(contact instanceof Contact, 'Invalid contact supplied'); if (this.getSize() === constants.K) { return false; } if (!this.hasContact(contact.nodeID)) { var index = _.sortedIndex(this._contacts, contact, function(contact) { return contact.lastSeen; }); this._contacts.splice(index, 0, contact); } return true; }; /** * Removes the contact from the bucket * @param {Contact} contact - Contact instance to remove from bucket * @returns {Boolean} removed - Indicates whether or not the contact was removed */ Bucket.prototype.removeContact = function(contact) { var index = this.indexOf(contact); if (index &gt;= 0) { this._contacts.splice(index, 1); return true; } return false; }; /** * Returns boolean indicating that the nodeID is contained in the bucket * @param {String} nodeID - 160 bit node ID * @returns {Boolean} */ Bucket.prototype.hasContact = function(nodeID) { for (var i = 0; i &lt; this.getSize(); i++) { if (this._contacts[i].nodeID === nodeID) { return true; } } return false; }; /** * Returns the index of the given contact * @param {Contact} contact - Contact instance for index check * @returns {Number} */ Bucket.prototype.indexOf = function(contact) { assert(contact instanceof Contact, 'Invalid contact supplied'); for (var i = 0; i &lt; this.getSize(); i++) { if (this.getContact(i).nodeID === contact.nodeID) { return i; } } return -1; }; module.exports = Bucket; × Search results Close Documentation generated by JSDoc 3.4.3 using the DocStrap template. "},"lib_storage.js.html":{"id":"lib_storage.js.html","title":"Source: lib/storage.js","body":" KadTools Modules kadkad/constantskad/contactskad/hookskad/storagekad/transportskad/utils Classes AddressPortContactBucketContactHTTPTransportItemLoggerMessagekad/storage.FSkad/storage.LocalStoragekad/storage.MemStoreNodeRouterRPCTCPTransportUDPTransport Events HTTPTransport#event:CONTACT_SEENHTTPTransport#event:FIND_NODEHTTPTransport#event:FIND_VALUEHTTPTransport#event:MESSAGE_DROPHTTPTransport#event:PINGHTTPTransport#event:readyHTTPTransport#event:STOREHTTPTransport#event:TIMEOUTNode#event:connectNode#event:disconnectNode#event:errorNode#event:joinNode#event:leaveRouter#event:addRouter#event:dropRouter#event:shiftRPC#event:CONTACT_SEENRPC#event:FIND_NODERPC#event:FIND_VALUERPC#event:MESSAGE_DROPRPC#event:PINGRPC#event:readyRPC#event:STORERPC#event:TIMEOUTTCPTransport#event:CONTACT_SEENTCPTransport#event:FIND_NODETCPTransport#event:FIND_VALUETCPTransport#event:MESSAGE_DROPTCPTransport#event:PINGTCPTransport#event:readyTCPTransport#event:STORETCPTransport#event:TIMEOUTUDPTransport#event:CONTACT_SEENUDPTransport#event:FIND_NODEUDPTransport#event:FIND_VALUEUDPTransport#event:MESSAGE_DROPUDPTransport#event:PINGUDPTransport#event:readyUDPTransport#event:STOREUDPTransport#event:TIMEOUT Tutorials Custom ContactsCustom Storage AdaptersCustom Transport AdaptersProtocol SpecificationUsing Hooks Externals kad-fskad-localstoragekad-memstore Source: lib/storage.js /** * @module kad/storage */ 'use strict'; module.exports = { /** * @external kad-fs * @see {@link https://github.com/kadtools/kad-fs} */ /** * Stores {@link Item} as file in the specified directory * @constructor * @param {String} datadir - Directory to store items */ FS: require('kad-fs'), /** * @external kad-localstorage * @see {@link https://github.com/kadtools/kad-localstorage} */ /** * Stores {@link Item} in browser localStorage using the given namespace * @constructor * @param {String} namespace - Prefix for keys in localStorage */ LocalStorage: require('kad-localstorage'), /** * @external kad-memstore * @see {@link https://github.com/kadtools/kad-memstore} */ /** * Stores {@link Item} in memory for testing * @constructor */ MemStore: require('kad-memstore') }; × Search results Close Documentation generated by JSDoc 3.4.3 using the DocStrap template. "},"lib_transports_http.js.html":{"id":"lib_transports_http.js.html","title":"Source: lib/transports/http.js","body":" KadTools Modules kadkad/constantskad/contactskad/hookskad/storagekad/transportskad/utils Classes AddressPortContactBucketContactHTTPTransportItemLoggerMessagekad/storage.FSkad/storage.LocalStoragekad/storage.MemStoreNodeRouterRPCTCPTransportUDPTransport Events HTTPTransport#event:CONTACT_SEENHTTPTransport#event:FIND_NODEHTTPTransport#event:FIND_VALUEHTTPTransport#event:MESSAGE_DROPHTTPTransport#event:PINGHTTPTransport#event:readyHTTPTransport#event:STOREHTTPTransport#event:TIMEOUTNode#event:connectNode#event:disconnectNode#event:errorNode#event:joinNode#event:leaveRouter#event:addRouter#event:dropRouter#event:shiftRPC#event:CONTACT_SEENRPC#event:FIND_NODERPC#event:FIND_VALUERPC#event:MESSAGE_DROPRPC#event:PINGRPC#event:readyRPC#event:STORERPC#event:TIMEOUTTCPTransport#event:CONTACT_SEENTCPTransport#event:FIND_NODETCPTransport#event:FIND_VALUETCPTransport#event:MESSAGE_DROPTCPTransport#event:PINGTCPTransport#event:readyTCPTransport#event:STORETCPTransport#event:TIMEOUTUDPTransport#event:CONTACT_SEENUDPTransport#event:FIND_NODEUDPTransport#event:FIND_VALUEUDPTransport#event:MESSAGE_DROPUDPTransport#event:PINGUDPTransport#event:readyUDPTransport#event:STOREUDPTransport#event:TIMEOUT Tutorials Custom ContactsCustom Storage AdaptersCustom Transport AdaptersProtocol SpecificationUsing Hooks Externals kad-fskad-localstoragekad-memstore Source: lib/transports/http.js 'use strict'; var AddressPortContact = require('../contacts/address-port-contact'); var Message = require('../message'); var assert = require('assert'); var inherits = require('util').inherits; var http = require('http'); var https = require('https'); var RPC = require('../rpc'); // create agents to enable http persistent connections: var httpagent = new http.Agent({keepAlive: true, keepAliveMsecs: 25000}); var httpsagent = new https.Agent({keepAlive: true, keepAliveMsecs: 25000}); /** * Transport adapter that sends and receives messages over HTTP * @constructor * @extends {RPC} * @param {AddressPortContact} contact - Your node's {@link Contact} instance * @param {Object} options * @param {Boolean} options.cors - Allow cross origin resource sharing * @param {Object} options.ssl - Options to pass to https.createServer() */ function HTTPTransport(contact, options) { if (!(this instanceof HTTPTransport)) { return new HTTPTransport(contact, options); } this._queuedResponses = {}; this._cors = options &amp;&amp; !!options.cors; this._sslopts = options &amp;&amp; options.ssl; this._protocol = this._sslopts ? https : http; // assign the correct agent based on the protocol: this._agent = this._sslopts ? httpsagent : httpagent; assert(contact instanceof AddressPortContact, 'Invalid contact supplied'); RPC.call(this, contact, options); this.on('MESSAGE_DROP', this._handleDroppedMessage.bind(this)); } inherits(HTTPTransport, RPC); /** * Opens the HTTP server and handles incoming messages * @private * @param {Function} done */ HTTPTransport.prototype._open = function(done) { var self = this; function createServer(handler) { return self._sslopts ? self._protocol.createServer(self._sslopts, handler) : self._protocol.createServer(handler); } this._server = createServer(function(req, res) { var payload = ''; var message = null; if (self._cors) { self._addCrossOriginHeaders(req, res); } if (req.method === 'OPTIONS') { return res.end(); } req.on('error', function(err) { self._log.warn('remote client terminated early: %s', err.message); self.receive(null); }); req.on('data', function(chunk) { payload += chunk.toString(); }); req.on('end', function() { var buffer = new Buffer(payload); try { message = Message.fromBuffer(buffer); } catch(err) { return self.receive(null); } if (Message.isRequest(message)) { self._queuedResponses[message.id] = res; } self.receive(buffer, {}); }); }); // we should disable nagling as all of our response gets sent in one go: this._server.on('connection', function(socket) { // disable the tcp nagle algorithm on the newly accepted socket: socket.setNoDelay(true); }); this._server.listen(this._contact.port, done); }; /** * Sends a RPC to the given contact * @private * @param {Buffer} data * @param {Contact} contact */ HTTPTransport.prototype._send = function(data, contact) { var self = this; var parsed = JSON.parse(data.toString()); function handleResponse(res) { var payload = ''; res.on('data', function(chunk) { payload += chunk.toString(); }); res.on('error', function(err) { self._log.error(err.message, 'No data received after request.'); self.receive(null); }); res.on('end', function() { self.receive(new Buffer(payload), {}); }); } if (this._queuedResponses[parsed.id]) { this._queuedResponses[parsed.id].end(data); delete this._queuedResponses[parsed.id]; return; } if (!contact.valid()) { this._log.warn('Refusing to send message to invalid contact'); return this.receive(null); } var req = self._protocol.request({ hostname: contact.address, port: contact.port, method: 'POST', agent: self._agent }, handleResponse); req.setNoDelay(true); // disable the tcp nagle algorithm req.on('error', function() { self.receive(null); }); req.end(data); }; /** * Close the underlying socket * @private */ HTTPTransport.prototype._close = function() { this._server.close(); }; /** * Adds CORS headers to the given response object * @private * @param {http.IncomingMessage} res */ HTTPTransport.prototype._addCrossOriginHeaders = function(req, res) { res.setHeader('Access-Control-Allow-Origin', req.headers.origin || '*'); res.setHeader('Access-Control-Allow-Methods', '*'); res.setHeader('Access-Control-Allow-Headers', '*'); res.setHeader('Access-Control-Allow-Credentials', 'true'); }; /** * Listen for dropped messages and make sure we clean up references * @private */ HTTPTransport.prototype._handleDroppedMessage = function(buffer) { var message; try { message = Message.fromBuffer(buffer); } catch (err) { return false; } if (this._queuedResponses[message.id]) { this._queuedResponses[message.id].end(); delete this._queuedResponses[message.id]; } return true; }; module.exports = HTTPTransport; × Search results Close Documentation generated by JSDoc 3.4.3 using the DocStrap template. "},"lib_rpc.js.html":{"id":"lib_rpc.js.html","title":"Source: lib/rpc.js","body":" KadTools Modules kadkad/constantskad/contactskad/hookskad/storagekad/transportskad/utils Classes AddressPortContactBucketContactHTTPTransportItemLoggerMessagekad/storage.FSkad/storage.LocalStoragekad/storage.MemStoreNodeRouterRPCTCPTransportUDPTransport Events HTTPTransport#event:CONTACT_SEENHTTPTransport#event:FIND_NODEHTTPTransport#event:FIND_VALUEHTTPTransport#event:MESSAGE_DROPHTTPTransport#event:PINGHTTPTransport#event:readyHTTPTransport#event:STOREHTTPTransport#event:TIMEOUTNode#event:connectNode#event:disconnectNode#event:errorNode#event:joinNode#event:leaveRouter#event:addRouter#event:dropRouter#event:shiftRPC#event:CONTACT_SEENRPC#event:FIND_NODERPC#event:FIND_VALUERPC#event:MESSAGE_DROPRPC#event:PINGRPC#event:readyRPC#event:STORERPC#event:TIMEOUTTCPTransport#event:CONTACT_SEENTCPTransport#event:FIND_NODETCPTransport#event:FIND_VALUETCPTransport#event:MESSAGE_DROPTCPTransport#event:PINGTCPTransport#event:readyTCPTransport#event:STORETCPTransport#event:TIMEOUTUDPTransport#event:CONTACT_SEENUDPTransport#event:FIND_NODEUDPTransport#event:FIND_VALUEUDPTransport#event:MESSAGE_DROPUDPTransport#event:PINGUDPTransport#event:readyUDPTransport#event:STOREUDPTransport#event:TIMEOUT Tutorials Custom ContactsCustom Storage AdaptersCustom Transport AdaptersProtocol SpecificationUsing Hooks Externals kad-fskad-localstoragekad-memstore Source: lib/rpc.js 'use strict'; var inherits = require('util').inherits; var events = require('events'); var assert = require('assert'); var async = require('async'); var constants = require('./constants'); var Contact = require('./contact'); var Message = require('./message'); var Logger = require('./logger'); /** * Represents an RPC interface * @constructor * @param {Contact} contact - Your node's {@link Contact} information * @param {Object} options * @param {Contact} options.replyto - Optional alternate public contact * @param {Logger} options.logger - Logger instance to use * @property {Number} readyState - Closed: 0, Transitioning: 1, Open: 2 */ function RPC(contact, options) { assert(this instanceof RPC, 'Invalid instance supplied'); assert(contact instanceof Contact, 'Invalid contact was supplied'); events.EventEmitter.call(this); options = options || {}; if (options.replyto) { assert(options.replyto instanceof Contact, 'Invalid contact was supplied'); } this._hooks = { before: {}, after: {} }; this._pendingCalls = {}; this._contact = options.replyto || contact; this._log = (options &amp;&amp; options.logger) || new Logger(0); this.readyState = 0; this.open(); } /** * Triggered when the underlying transport is open * @event RPC#ready */ /** * Triggered when a contact is seen * @event RPC#CONTACT_SEEN * @param {Contact} contact - The contact that was just encountered */ /** * Triggered when a RPC message times out * @event RPC#TIMEOUT * @param {Contact} contact - The contact that did not respond * @param {Message} message - The message sent that timed out */ /** * Triggered when a FIND_NODE RPC is received * @event RPC#FIND_NODE * @param {Message} message - The message received */ /** * Triggered when a FIND_VALUE RPC message is received * @event RPC#FIND_VALUE * @param {Message} message - The message received */ /** * Triggered when a PING RPC message is received * @event RPC#PING * @param {Message} message - The message received */ /** * Triggered when a STORE RPC message is received * @event RPC#STORE * @param {Message} message - The message received */ /** * Triggered when an invalid RPC message is dropped * @event RPC#MESSAGE_DROP * @param {Buffer} message - The raw invalid message received */ inherits(RPC, events.EventEmitter); /** * Opens the underlying transport * @emits RPC#ready * @param {RPC~openCallback} callback - Called when the transport is opened */ RPC.prototype.open = function(callback) { var self = this; if (callback) { self.once('ready', callback); } self.readyState = 1; self._trigger('before:open', [], function() { self._open(function() { self.readyState = 2; self.emit('ready'); self._trigger('after:open'); }); self._expirator = setInterval( self._expireCalls.bind(self), constants.T_RESPONSETIMEOUT + 5 ); }); }; /** * This callback is called upon completion of {@link RPC#open} * @callback RPC~openCallback */ /** * Closes the underlying transport * @param {RPC~closeCallback} callback - Called when the transport is closed */ RPC.prototype.close = function(callback) { var self = this; self.readyState = 1; self._trigger('before:close', [], function() { self._close(); self.readyState = 0; self._trigger('after:close'); clearInterval(self._expirator); if (callback) { callback(); } }); }; /** * This callback is called upon completion of {@link RPC#open} * @callback RPC~closeCallback */ /** * Send a RPC to the given contact * @param {Contact} contact - Delivery target for message * @param {Message} message - Message to send to target * @param {RPC~sendCallback} callback - Response handler function */ RPC.prototype.send = function(contact, message, callback) { var self = this; contact = this._createContact(contact); assert(contact instanceof Contact, 'Invalid contact supplied'); assert(message instanceof Message, 'Invalid message supplied'); if (Message.isRequest(message)) { this._log.info('sending %s message to %j', message.method, contact); } else { this._log.info('replying to message to %s', message.id); } this._trigger('before:serialize', [message], function() { var serialized = message.serialize(); self._trigger('after:serialize'); self._trigger('before:send', [serialized, contact], function() { if (Message.isRequest(message) &amp;&amp; typeof callback === 'function') { self._log.debug('queuing callback for reponse to %s', message.id); self._pendingCalls[message.id] = { timestamp: Date.now(), callback: callback, contact: contact, message: message }; } else { self._log.debug('not waiting on callback for message %s', message.id); } self._send(message.serialize(), contact); self._trigger('after:send'); }); }); }; /** * This callback is called upon receipt of a response from {@link RPC#send} * @callback RPC~sendCallback * @param {Error} err - The error object, if any * @param {Message} message - The received response {@link Message} */ /** * Handle incoming messages * @param {Buffer} buffer - Raw binary data to be processed by the RPC handler */ RPC.prototype.receive = function(buffer) { var self = this, message, contact; function deserialize() { message = Message.fromBuffer(buffer); self._trigger('after:deserialize'); if (Message.isRequest(message)) { contact = self._createContact(message.params.contact); } else { contact = self._createContact(message.result.contact); } self._log.info('received valid message from %j', contact); } if (!buffer) { self._log.warn('missing or empty reply from contact'); return self.emit('MESSAGE_DROP'); } this._trigger('before:deserialize', [buffer], function() { try { deserialize(); } catch(err) { self._log.error('failed to handle message, reason: %s', err.message); return self.emit('MESSAGE_DROP', buffer); } self.emit('CONTACT_SEEN', contact); self._trigger('before:receive', [message, contact], function(err) { if (err) { return self.emit('MESSAGE_DROP', buffer); } self._execPendingCallback(message, contact); }); }); }; /** * Registers a &quot;before&quot; hook * @param {String} event - Name of the event to catch * @param {Function} handler - Event handler to register */ RPC.prototype.before = function(event, handler) { return this._register('before', event, handler); }; /** * Registers an &quot;after&quot; hook * @param {String} event - Name of the event to catch * @param {Function} handler - Event handler to register */ RPC.prototype.after = function(event, handler) { return this._register('after', event, handler); }; /** * Registers a middleware or &quot;hook&quot; in a set * @private * @param {String} time - One of &quot;before&quot; or &quot;after&quot; * @param {String} event - Name of the event to catch * @param {Function} handler - Event handler to register */ RPC.prototype._register = function(time, event, handler) { assert(Object.keys(this._hooks).indexOf(time) !== -1, 'Invalid hook'); assert(typeof event === 'string', 'Invalid event supplied'); assert(typeof handler === 'function', 'Invalid handler supplied'); if (!this._hooks[time][event]) { this._hooks[time][event] = []; } this._hooks[time][event].push(handler); return this; }; /** * Triggers a middleware or &quot;hook&quot; set * @private * @param {String} event - Name of the event to trigger * @param {Array} args - Arguments to pass to event handlers * @param {Function} callback - Fired after all events are triggered */ RPC.prototype._trigger = function(event, args, complete) { var self = this; var hook = event.split(':')[0]; var name = event.split(':')[1]; var callback = complete || function() {}; if (!this._hooks[hook][name]) { return callback(); } var stack = this._hooks[hook][name].map(function(fn) { return fn.bind.apply(fn, [self].concat(args || [])); }); async.series(stack, function(err) { if (err) { return callback(err); } callback(); }); }; /** * Create a contact object from the supplied contact information * @private * @param {Object} options - Data to be passed to the transport's * {@link Contact} constructor */ RPC.prototype._createContact = function(options) { return new this._contact.constructor(options); }; /** * Executes the pending callback for a given message * @private * @param {Message} message - Message to handle any callbacks for * @param {Contact} contact - Contact who sent the message */ RPC.prototype._execPendingCallback = function(message) { var pendingCall = this._pendingCalls[message.id]; this._log.debug('checking pending rpc callback stack for %s', message.id); if (Message.isResponse(message) &amp;&amp; pendingCall) { pendingCall.callback(null, message); delete this._pendingCalls[message.id]; } else if (Message.isRequest(message)) { if (constants.MESSAGE_TYPES.indexOf(message.method) === -1) { this.emit('MESSAGE_DROP', message.serialize()); this._log.warn( 'message references unsupported method %s', message.method ); } else { this.emit(message.method, message); } } else { this.emit('MESSAGE_DROP', message.serialize()); this._log.warn('dropping received late response to %s', message.id); } this._trigger('after:receive', []); }; /** * Expire RPCs that have not received a reply * @private */ RPC.prototype._expireCalls = function() { this._log.debug('checking pending rpc callbacks for expirations'); for (var rpcID in this._pendingCalls) { var pendingCall = this._pendingCalls[rpcID]; var timePassed = Date.now() - pendingCall.timestamp; if (timePassed &gt; constants.T_RESPONSETIMEOUT) { this._log.warn('rpc call %s timed out', rpcID); this.emit('TIMEOUT', pendingCall.contact, pendingCall.message); pendingCall.callback(new Error('RPC with ID `' + rpcID + '` timed out')); delete this._pendingCalls[rpcID]; } } }; /** * Unimplemented stub, called on close() * @abstract */ RPC.prototype._close = function() { throw new Error('Method not implemented'); }; /** * Unimplemented stub, called on send() * @abstract * @param {Buffer} data - Raw binary data to send * @param {Contact} contact - Target peer to send data */ RPC.prototype._send = function() { throw new Error('Method not implemented'); }; /** * Unimplemented stub, called on constructor * @abstract */ RPC.prototype._open = function(done) { setImmediate(done); }; module.exports = RPC; × Search results Close Documentation generated by JSDoc 3.4.3 using the DocStrap template. "},"lib_item.js.html":{"id":"lib_item.js.html","title":"Source: lib/item.js","body":" KadTools Modules kadkad/constantskad/contactskad/hookskad/storagekad/transportskad/utils Classes AddressPortContactBucketContactHTTPTransportItemLoggerMessagekad/storage.FSkad/storage.LocalStoragekad/storage.MemStoreNodeRouterRPCTCPTransportUDPTransport Events HTTPTransport#event:CONTACT_SEENHTTPTransport#event:FIND_NODEHTTPTransport#event:FIND_VALUEHTTPTransport#event:MESSAGE_DROPHTTPTransport#event:PINGHTTPTransport#event:readyHTTPTransport#event:STOREHTTPTransport#event:TIMEOUTNode#event:connectNode#event:disconnectNode#event:errorNode#event:joinNode#event:leaveRouter#event:addRouter#event:dropRouter#event:shiftRPC#event:CONTACT_SEENRPC#event:FIND_NODERPC#event:FIND_VALUERPC#event:MESSAGE_DROPRPC#event:PINGRPC#event:readyRPC#event:STORERPC#event:TIMEOUTTCPTransport#event:CONTACT_SEENTCPTransport#event:FIND_NODETCPTransport#event:FIND_VALUETCPTransport#event:MESSAGE_DROPTCPTransport#event:PINGTCPTransport#event:readyTCPTransport#event:STORETCPTransport#event:TIMEOUTUDPTransport#event:CONTACT_SEENUDPTransport#event:FIND_NODEUDPTransport#event:FIND_VALUEUDPTransport#event:MESSAGE_DROPUDPTransport#event:PINGUDPTransport#event:readyUDPTransport#event:STOREUDPTransport#event:TIMEOUT Tutorials Custom ContactsCustom Storage AdaptersCustom Transport AdaptersProtocol SpecificationUsing Hooks Externals kad-fskad-localstoragekad-memstore Source: lib/item.js 'use strict'; var assert = require('assert'); var utils = require('./utils'); /** * Storage model for DHT items, which is serialized to JSON before being passed * to the storage adapter * @constructor * @param {String} key - Lookup key * @param {String|Object|Array} value - Stored value * @param {String} publisher - Original publisher's nodeID * @param {Number} timestamp - Optional UNIX timestamp of original publication */ function Item(key, value, publisher, timestamp) { if (!(this instanceof Item)) { return new Item(key, value, publisher, timestamp); } assert(typeof key === 'string', 'Invalid key supplied'); assert(utils.isValidKey(publisher), 'Invalid publisher nodeID supplied'); if (timestamp) { assert(typeof timestamp === 'number', 'Invalid timestamp supplied'); assert(Date.now() &gt;= timestamp, 'Timestamp cannot be in the future'); } this.key = key; this.value = value; this.publisher = publisher; this.timestamp = timestamp || Date.now(); } module.exports = Item; × Search results Close Documentation generated by JSDoc 3.4.3 using the DocStrap template. "},"lib_logger.js.html":{"id":"lib_logger.js.html","title":"Source: lib/logger.js","body":" KadTools Modules kadkad/constantskad/contactskad/hookskad/storagekad/transportskad/utils Classes AddressPortContactBucketContactHTTPTransportItemLoggerMessagekad/storage.FSkad/storage.LocalStoragekad/storage.MemStoreNodeRouterRPCTCPTransportUDPTransport Events HTTPTransport#event:CONTACT_SEENHTTPTransport#event:FIND_NODEHTTPTransport#event:FIND_VALUEHTTPTransport#event:MESSAGE_DROPHTTPTransport#event:PINGHTTPTransport#event:readyHTTPTransport#event:STOREHTTPTransport#event:TIMEOUTNode#event:connectNode#event:disconnectNode#event:errorNode#event:joinNode#event:leaveRouter#event:addRouter#event:dropRouter#event:shiftRPC#event:CONTACT_SEENRPC#event:FIND_NODERPC#event:FIND_VALUERPC#event:MESSAGE_DROPRPC#event:PINGRPC#event:readyRPC#event:STORERPC#event:TIMEOUTTCPTransport#event:CONTACT_SEENTCPTransport#event:FIND_NODETCPTransport#event:FIND_VALUETCPTransport#event:MESSAGE_DROPTCPTransport#event:PINGTCPTransport#event:readyTCPTransport#event:STORETCPTransport#event:TIMEOUTUDPTransport#event:CONTACT_SEENUDPTransport#event:FIND_NODEUDPTransport#event:FIND_VALUEUDPTransport#event:MESSAGE_DROPUDPTransport#event:PINGUDPTransport#event:readyUDPTransport#event:STOREUDPTransport#event:TIMEOUT Tutorials Custom ContactsCustom Storage AdaptersCustom Transport AdaptersProtocol SpecificationUsing Hooks Externals kad-fskad-localstoragekad-memstore Source: lib/logger.js 'use strict'; var colors = require('colors/safe'); /** * Kad, by default, prints log messages to the console using pretty-printed * status messages. There are different types of messages indicating the nature * or severity, `error`, `warn`, `info`, `debug`. You can tell Kad which of these * messages types you want to see by passing a {@link Logger} with option from * 0 - 4. * @constructor * @param {Number} level - Log verbosity (0-4) * @param {String} prefix - Optional prefix for log output */ function Logger(level, prefix) { if (!(this instanceof Logger)) { return new Logger(level, prefix); } this.prefix = colors.bold(' :' + (prefix || 'kad') + ': '); this.level = level || 0; this.types = { debug: { level: 4, color: colors.magenta }, info: { level: 3, color: colors.blue }, warn: { level: 2, color: colors.yellow }, error: { level: 1, color: colors.red } }; this._bindLogTypes(); } /** * Sets up log types as instance methods * @private */ Logger.prototype._bindLogTypes = function() { var self = this; Object.keys(this.types).forEach(function(type) { self[type] = function() { if (self.level &gt;= self.types[type].level) { var prefix = self.prefix + self.types[type].color('{' + type + '}'); var args = Array.prototype.slice.call(arguments); args[0] = prefix + ' ' + args[0]; console.log.apply(console, args); } }; }); }; module.exports = Logger; × Search results Close Documentation generated by JSDoc 3.4.3 using the DocStrap template. "},"lib_message.js.html":{"id":"lib_message.js.html","title":"Source: lib/message.js","body":" KadTools Modules kadkad/constantskad/contactskad/hookskad/storagekad/transportskad/utils Classes AddressPortContactBucketContactHTTPTransportItemLoggerMessagekad/storage.FSkad/storage.LocalStoragekad/storage.MemStoreNodeRouterRPCTCPTransportUDPTransport Events HTTPTransport#event:CONTACT_SEENHTTPTransport#event:FIND_NODEHTTPTransport#event:FIND_VALUEHTTPTransport#event:MESSAGE_DROPHTTPTransport#event:PINGHTTPTransport#event:readyHTTPTransport#event:STOREHTTPTransport#event:TIMEOUTNode#event:connectNode#event:disconnectNode#event:errorNode#event:joinNode#event:leaveRouter#event:addRouter#event:dropRouter#event:shiftRPC#event:CONTACT_SEENRPC#event:FIND_NODERPC#event:FIND_VALUERPC#event:MESSAGE_DROPRPC#event:PINGRPC#event:readyRPC#event:STORERPC#event:TIMEOUTTCPTransport#event:CONTACT_SEENTCPTransport#event:FIND_NODETCPTransport#event:FIND_VALUETCPTransport#event:MESSAGE_DROPTCPTransport#event:PINGTCPTransport#event:readyTCPTransport#event:STORETCPTransport#event:TIMEOUTUDPTransport#event:CONTACT_SEENUDPTransport#event:FIND_NODEUDPTransport#event:FIND_VALUEUDPTransport#event:MESSAGE_DROPUDPTransport#event:PINGUDPTransport#event:readyUDPTransport#event:STOREUDPTransport#event:TIMEOUT Tutorials Custom ContactsCustom Storage AdaptersCustom Transport AdaptersProtocol SpecificationUsing Hooks Externals kad-fskad-localstoragekad-memstore Source: lib/message.js 'use strict'; var constants = require('./constants'); var hat = require('hat'); var merge = require('merge'); /** * Represents a [JSON-RPC 2.0](http://www.jsonrpc.org/specification) request or * response; used by {@link RPC#send}. * * Note that the value of the contact property will be replaced by the * {@link Contact} your implementation uses. * * The decision to use JSON-RPC as the message format was made to allow for * other language implementations and services to easily communicate with the * network, using a widely recognized and used format. * @constructor * @param {Object} spec * @param {String} spec.id - Message ID * @param {String} spec.method - Method name to include in request message * @param {Object} spec.params - Named parameters for request message * @param {Object} spec.result - Result data for response message * @param {Error} spec.error - Error object to convert to message */ function Message(spec) { if (!(this instanceof Message)) { return new Message(spec); } this.jsonrpc = '2.0'; if (Message.isRequest(spec)) { this.id = spec.id || Message.createID(); this.method = spec.method; this.params = spec.params; } else if (Message.isResponse(spec)) { this.id = spec.id; this.result = merge({}, spec.result); if (spec.error) { this.error = { code: -32603, message: spec.error.message }; } } else { throw new Error('Invalid message specification'); } } /** * Serialize message to a Buffer * @returns {Buffer} */ Message.prototype.serialize = function() { return new Buffer(JSON.stringify(this), 'utf8'); }; /** * Returns a boolean indicating if this message is a request * @param {Message} message - Message instance to inspect * @returns {Boolean} */ Message.isRequest = function(parsed) { return !!(parsed.method &amp;&amp; parsed.params); }; /** * Returns a boolean indicating if this message is a response * @param {Message} message - Message instance to inspect * @returns {Boolean} */ Message.isResponse = function(parsed) { return !!(parsed.id &amp;&amp; (parsed.result || parsed.error)); }; /** * Create a Message instance from a buffer * @param {Buffer} buffer - Binary blob to convert to message object * @returns {Message} */ Message.fromBuffer = function(buffer) { function _convertByteArrays(key, value) { return value &amp;&amp; value.type === 'Buffer' ? new Buffer(value.data) : value; } var parsed = JSON.parse(buffer.toString('utf8'), _convertByteArrays); var message = new Message(parsed); return message; }; /** * Returns a message id * @returns {String} */ Message.createID = function() { return hat.rack(constants.B)(); }; module.exports = Message; × Search results Close Documentation generated by JSDoc 3.4.3 using the DocStrap template. "},"lib_hooks_blacklist.js.html":{"id":"lib_hooks_blacklist.js.html","title":"Source: lib/hooks/blacklist.js","body":" KadTools Modules kadkad/constantskad/contactskad/hookskad/storagekad/transportskad/utils Classes AddressPortContactBucketContactHTTPTransportItemLoggerMessagekad/storage.FSkad/storage.LocalStoragekad/storage.MemStoreNodeRouterRPCTCPTransportUDPTransport Events HTTPTransport#event:CONTACT_SEENHTTPTransport#event:FIND_NODEHTTPTransport#event:FIND_VALUEHTTPTransport#event:MESSAGE_DROPHTTPTransport#event:PINGHTTPTransport#event:readyHTTPTransport#event:STOREHTTPTransport#event:TIMEOUTNode#event:connectNode#event:disconnectNode#event:errorNode#event:joinNode#event:leaveRouter#event:addRouter#event:dropRouter#event:shiftRPC#event:CONTACT_SEENRPC#event:FIND_NODERPC#event:FIND_VALUERPC#event:MESSAGE_DROPRPC#event:PINGRPC#event:readyRPC#event:STORERPC#event:TIMEOUTTCPTransport#event:CONTACT_SEENTCPTransport#event:FIND_NODETCPTransport#event:FIND_VALUETCPTransport#event:MESSAGE_DROPTCPTransport#event:PINGTCPTransport#event:readyTCPTransport#event:STORETCPTransport#event:TIMEOUTUDPTransport#event:CONTACT_SEENUDPTransport#event:FIND_NODEUDPTransport#event:FIND_VALUEUDPTransport#event:MESSAGE_DROPUDPTransport#event:PINGUDPTransport#event:readyUDPTransport#event:STOREUDPTransport#event:TIMEOUT Tutorials Custom ContactsCustom Storage AdaptersCustom Transport AdaptersProtocol SpecificationUsing Hooks Externals kad-fskad-localstoragekad-memstore Source: lib/hooks/blacklist.js 'use strict'; var assert = require('assert'); /** * Factory for blacklist middleware * @param {Array} blacklist - array of nodeID's to ban * @returns {Function} */ module.exports = function BlacklistFactory(blacklist) { assert(Array.isArray(blacklist), 'Invalid blacklist supplied'); return function blacklister(message, contact, next) { if (blacklist.indexOf(contact.nodeID) !== -1) { return next(new Error('Contact is in the blacklist')); } next(); }; }; × Search results Close Documentation generated by JSDoc 3.4.3 using the DocStrap template. "},"lib_hooks_protocol.js.html":{"id":"lib_hooks_protocol.js.html","title":"Source: lib/hooks/protocol.js","body":" KadTools Modules kadkad/constantskad/contactskad/hookskad/storagekad/transportskad/utils Classes AddressPortContactBucketContactHTTPTransportItemLoggerMessagekad/storage.FSkad/storage.LocalStoragekad/storage.MemStoreNodeRouterRPCTCPTransportUDPTransport Events HTTPTransport#event:CONTACT_SEENHTTPTransport#event:FIND_NODEHTTPTransport#event:FIND_VALUEHTTPTransport#event:MESSAGE_DROPHTTPTransport#event:PINGHTTPTransport#event:readyHTTPTransport#event:STOREHTTPTransport#event:TIMEOUTNode#event:connectNode#event:disconnectNode#event:errorNode#event:joinNode#event:leaveRouter#event:addRouter#event:dropRouter#event:shiftRPC#event:CONTACT_SEENRPC#event:FIND_NODERPC#event:FIND_VALUERPC#event:MESSAGE_DROPRPC#event:PINGRPC#event:readyRPC#event:STORERPC#event:TIMEOUTTCPTransport#event:CONTACT_SEENTCPTransport#event:FIND_NODETCPTransport#event:FIND_VALUETCPTransport#event:MESSAGE_DROPTCPTransport#event:PINGTCPTransport#event:readyTCPTransport#event:STORETCPTransport#event:TIMEOUTUDPTransport#event:CONTACT_SEENUDPTransport#event:FIND_NODEUDPTransport#event:FIND_VALUEUDPTransport#event:MESSAGE_DROPUDPTransport#event:PINGUDPTransport#event:readyUDPTransport#event:STOREUDPTransport#event:TIMEOUT Tutorials Custom ContactsCustom Storage AdaptersCustom Transport AdaptersProtocol SpecificationUsing Hooks Externals kad-fskad-localstoragekad-memstore Source: lib/hooks/protocol.js 'use strict'; var assert = require('assert'); var merge = require('merge'); var Message = require('../message'); /** * Factory for protocol extentions * @function * @param {Object} protocolspec - dictionary of methods * @returns {Function} */ module.exports = function ProtocolFactory(protocolspec) { assert(typeof protocolspec === 'object', 'Invalid protocol specification'); return function protocol(message, contact, next) { var rpc = this; // if this is a response, just pass it along to execute callback if (Message.isResponse(message)) { return next(); } // lookup the method defined in the protocol spec var method = protocolspec[message.method]; // pass on message if it is not defined in protocol if (typeof method !== 'function') { return next(); } // call the method and halt the middleware stack here method.call(rpc, message.params, function(err, result) { var reply = new Message({ error: err, result: merge({ contact: rpc._contact }, result), id: message.id }); rpc.send(contact, reply); }); }; }; × Search results Close Documentation generated by JSDoc 3.4.3 using the DocStrap template. "},"lib_hooks_whitelist.js.html":{"id":"lib_hooks_whitelist.js.html","title":"Source: lib/hooks/whitelist.js","body":" KadTools Modules kadkad/constantskad/contactskad/hookskad/storagekad/transportskad/utils Classes AddressPortContactBucketContactHTTPTransportItemLoggerMessagekad/storage.FSkad/storage.LocalStoragekad/storage.MemStoreNodeRouterRPCTCPTransportUDPTransport Events HTTPTransport#event:CONTACT_SEENHTTPTransport#event:FIND_NODEHTTPTransport#event:FIND_VALUEHTTPTransport#event:MESSAGE_DROPHTTPTransport#event:PINGHTTPTransport#event:readyHTTPTransport#event:STOREHTTPTransport#event:TIMEOUTNode#event:connectNode#event:disconnectNode#event:errorNode#event:joinNode#event:leaveRouter#event:addRouter#event:dropRouter#event:shiftRPC#event:CONTACT_SEENRPC#event:FIND_NODERPC#event:FIND_VALUERPC#event:MESSAGE_DROPRPC#event:PINGRPC#event:readyRPC#event:STORERPC#event:TIMEOUTTCPTransport#event:CONTACT_SEENTCPTransport#event:FIND_NODETCPTransport#event:FIND_VALUETCPTransport#event:MESSAGE_DROPTCPTransport#event:PINGTCPTransport#event:readyTCPTransport#event:STORETCPTransport#event:TIMEOUTUDPTransport#event:CONTACT_SEENUDPTransport#event:FIND_NODEUDPTransport#event:FIND_VALUEUDPTransport#event:MESSAGE_DROPUDPTransport#event:PINGUDPTransport#event:readyUDPTransport#event:STOREUDPTransport#event:TIMEOUT Tutorials Custom ContactsCustom Storage AdaptersCustom Transport AdaptersProtocol SpecificationUsing Hooks Externals kad-fskad-localstoragekad-memstore Source: lib/hooks/whitelist.js 'use strict'; var assert = require('assert'); /** * Factory for whitelist middleware * @function * @param {Array} whitelist - list of nodeID's to allow * @returns {Function} */ module.exports = function WhitelistFactory(whitelist) { assert(Array.isArray(whitelist), 'Invalid whitelist supplied'); return function whitelister(message, contact, next) { if (whitelist.indexOf(contact.nodeID) === -1) { return next(new Error('Contact is not in the whitelist')); } next(); }; }; × Search results Close Documentation generated by JSDoc 3.4.3 using the DocStrap template. "},"index.js.html":{"id":"index.js.html","title":"Source: index.js","body":" KadTools Modules kadkad/constantskad/contactskad/hookskad/storagekad/transportskad/utils Classes AddressPortContactBucketContactHTTPTransportItemLoggerMessagekad/storage.FSkad/storage.LocalStoragekad/storage.MemStoreNodeRouterRPCTCPTransportUDPTransport Events HTTPTransport#event:CONTACT_SEENHTTPTransport#event:FIND_NODEHTTPTransport#event:FIND_VALUEHTTPTransport#event:MESSAGE_DROPHTTPTransport#event:PINGHTTPTransport#event:readyHTTPTransport#event:STOREHTTPTransport#event:TIMEOUTNode#event:connectNode#event:disconnectNode#event:errorNode#event:joinNode#event:leaveRouter#event:addRouter#event:dropRouter#event:shiftRPC#event:CONTACT_SEENRPC#event:FIND_NODERPC#event:FIND_VALUERPC#event:MESSAGE_DROPRPC#event:PINGRPC#event:readyRPC#event:STORERPC#event:TIMEOUTTCPTransport#event:CONTACT_SEENTCPTransport#event:FIND_NODETCPTransport#event:FIND_VALUETCPTransport#event:MESSAGE_DROPTCPTransport#event:PINGTCPTransport#event:readyTCPTransport#event:STORETCPTransport#event:TIMEOUTUDPTransport#event:CONTACT_SEENUDPTransport#event:FIND_NODEUDPTransport#event:FIND_VALUEUDPTransport#event:MESSAGE_DROPUDPTransport#event:PINGUDPTransport#event:readyUDPTransport#event:STOREUDPTransport#event:TIMEOUT Tutorials Custom ContactsCustom Storage AdaptersCustom Transport AdaptersProtocol SpecificationUsing Hooks Externals kad-fskad-localstoragekad-memstore Source: index.js /** * @module kad * @license GPL-3.0 * @author Gordon Hall gordon@gordonwritescode.com */ 'use strict'; /** {@link Bucket} */ module.exports.Bucket = require('./lib/bucket'); /** {@link Contact} */ module.exports.Contact = require('./lib/contact'); /** {@link Logger} */ module.exports.Logger = require('./lib/logger'); /** {@link Message} */ module.exports.Message = require('./lib/message'); /** {@link Node} */ module.exports.Node = require('./lib/node'); /** {@link Router} */ module.exports.Router = require('./lib/router'); /** {@link RPC} */ module.exports.RPC = require('./lib/rpc'); /** {@link module:kad/contacts} */ module.exports.contacts = require('./lib/contacts'); /** {@link module:kad/transports} */ module.exports.transports = require('./lib/transports'); /** {@link module:kad/hooks} */ module.exports.hooks = require('./lib/hooks'); /** {@link module:kad.storage} */ module.exports.storage = require('./lib/storage'); /** {@link module:kad/utils} */ module.exports.utils = require('./lib/utils'); /** {@link module:kad/constants} */ module.exports.constants = require('./lib/constants'); × Search results Close Documentation generated by JSDoc 3.4.3 using the DocStrap template. "},"lib_constants.js.html":{"id":"lib_constants.js.html","title":"Source: lib/constants.js","body":" KadTools Modules kadkad/constantskad/contactskad/hookskad/storagekad/transportskad/utils Classes AddressPortContactBucketContactHTTPTransportItemLoggerMessagekad/storage.FSkad/storage.LocalStoragekad/storage.MemStoreNodeRouterRPCTCPTransportUDPTransport Events HTTPTransport#event:CONTACT_SEENHTTPTransport#event:FIND_NODEHTTPTransport#event:FIND_VALUEHTTPTransport#event:MESSAGE_DROPHTTPTransport#event:PINGHTTPTransport#event:readyHTTPTransport#event:STOREHTTPTransport#event:TIMEOUTNode#event:connectNode#event:disconnectNode#event:errorNode#event:joinNode#event:leaveRouter#event:addRouter#event:dropRouter#event:shiftRPC#event:CONTACT_SEENRPC#event:FIND_NODERPC#event:FIND_VALUERPC#event:MESSAGE_DROPRPC#event:PINGRPC#event:readyRPC#event:STORERPC#event:TIMEOUTTCPTransport#event:CONTACT_SEENTCPTransport#event:FIND_NODETCPTransport#event:FIND_VALUETCPTransport#event:MESSAGE_DROPTCPTransport#event:PINGTCPTransport#event:readyTCPTransport#event:STORETCPTransport#event:TIMEOUTUDPTransport#event:CONTACT_SEENUDPTransport#event:FIND_NODEUDPTransport#event:FIND_VALUEUDPTransport#event:MESSAGE_DROPUDPTransport#event:PINGUDPTransport#event:readyUDPTransport#event:STOREUDPTransport#event:TIMEOUT Tutorials Custom ContactsCustom Storage AdaptersCustom Transport AdaptersProtocol SpecificationUsing Hooks Externals kad-fskad-localstoragekad-memstore Source: lib/constants.js /** * @module kad/constants */ 'use strict'; var ms = require('ms'); module.exports = { /** @constant {Number} ALPHA - Degree of parallelism */ ALPHA: 3, /** @constant {Number} B - Number of bits for nodeID creation */ B: 160, /** @constant {Number} K - Number of contacts held in a bucket */ K: 20, /** @constant {Number} T_REFRESH - Interval for performing router refresh */ T_REFRESH: ms('3600s'), /** @constant {Number} T_REPLICATE - Interval for replicating local data */ T_REPLICATE: ms('3600s'), /** @constant {Number} T_REPUBLISH - Interval for republishing data */ T_REPUBLISH: ms('86400s'), /** @constant {Number} T_EXPIRE - Interval for expiring local data entries */ T_EXPIRE: ms('86405s'), /** @constant {Number} T_RESPONSETIMEOUT - Time to wait for RPC response */ T_RESPONSETIMEOUT: ms('5s'), /** @constant {Array} MESSAGE_TYPES - Allowed RPC methods */ MESSAGE_TYPES: [ 'PING', 'STORE', 'FIND_NODE', 'FIND_VALUE' ] }; × Search results Close Documentation generated by JSDoc 3.4.3 using the DocStrap template. "},"lib_contacts_index.js.html":{"id":"lib_contacts_index.js.html","title":"Source: lib/contacts/index.js","body":" KadTools Modules kadkad/constantskad/contactskad/hookskad/storagekad/transportskad/utils Classes AddressPortContactBucketContactHTTPTransportItemLoggerMessagekad/storage.FSkad/storage.LocalStoragekad/storage.MemStoreNodeRouterRPCTCPTransportUDPTransport Events HTTPTransport#event:CONTACT_SEENHTTPTransport#event:FIND_NODEHTTPTransport#event:FIND_VALUEHTTPTransport#event:MESSAGE_DROPHTTPTransport#event:PINGHTTPTransport#event:readyHTTPTransport#event:STOREHTTPTransport#event:TIMEOUTNode#event:connectNode#event:disconnectNode#event:errorNode#event:joinNode#event:leaveRouter#event:addRouter#event:dropRouter#event:shiftRPC#event:CONTACT_SEENRPC#event:FIND_NODERPC#event:FIND_VALUERPC#event:MESSAGE_DROPRPC#event:PINGRPC#event:readyRPC#event:STORERPC#event:TIMEOUTTCPTransport#event:CONTACT_SEENTCPTransport#event:FIND_NODETCPTransport#event:FIND_VALUETCPTransport#event:MESSAGE_DROPTCPTransport#event:PINGTCPTransport#event:readyTCPTransport#event:STORETCPTransport#event:TIMEOUTUDPTransport#event:CONTACT_SEENUDPTransport#event:FIND_NODEUDPTransport#event:FIND_VALUEUDPTransport#event:MESSAGE_DROPUDPTransport#event:PINGUDPTransport#event:readyUDPTransport#event:STOREUDPTransport#event:TIMEOUT Tutorials Custom ContactsCustom Storage AdaptersCustom Transport AdaptersProtocol SpecificationUsing Hooks Externals kad-fskad-localstoragekad-memstore Source: lib/contacts/index.js /** * @module kad/contacts */ 'use strict'; module.exports = { /** {@link AddressPortContact} */ AddressPortContact: require('./address-port-contact') }; × Search results Close Documentation generated by JSDoc 3.4.3 using the DocStrap template. "},"lib_hooks_index.js.html":{"id":"lib_hooks_index.js.html","title":"Source: lib/hooks/index.js","body":" KadTools Modules kadkad/constantskad/contactskad/hookskad/storagekad/transportskad/utils Classes AddressPortContactBucketContactHTTPTransportItemLoggerMessagekad/storage.FSkad/storage.LocalStoragekad/storage.MemStoreNodeRouterRPCTCPTransportUDPTransport Events HTTPTransport#event:CONTACT_SEENHTTPTransport#event:FIND_NODEHTTPTransport#event:FIND_VALUEHTTPTransport#event:MESSAGE_DROPHTTPTransport#event:PINGHTTPTransport#event:readyHTTPTransport#event:STOREHTTPTransport#event:TIMEOUTNode#event:connectNode#event:disconnectNode#event:errorNode#event:joinNode#event:leaveRouter#event:addRouter#event:dropRouter#event:shiftRPC#event:CONTACT_SEENRPC#event:FIND_NODERPC#event:FIND_VALUERPC#event:MESSAGE_DROPRPC#event:PINGRPC#event:readyRPC#event:STORERPC#event:TIMEOUTTCPTransport#event:CONTACT_SEENTCPTransport#event:FIND_NODETCPTransport#event:FIND_VALUETCPTransport#event:MESSAGE_DROPTCPTransport#event:PINGTCPTransport#event:readyTCPTransport#event:STORETCPTransport#event:TIMEOUTUDPTransport#event:CONTACT_SEENUDPTransport#event:FIND_NODEUDPTransport#event:FIND_VALUEUDPTransport#event:MESSAGE_DROPUDPTransport#event:PINGUDPTransport#event:readyUDPTransport#event:STOREUDPTransport#event:TIMEOUT Tutorials Custom ContactsCustom Storage AdaptersCustom Transport AdaptersProtocol SpecificationUsing Hooks Externals kad-fskad-localstoragekad-memstore Source: lib/hooks/index.js /** * @module kad/hooks */ 'use strict'; module.exports = { /** * Creates a blacklist filter for rejecting messages from defined nodeIDs * @function * @param {Array} nodeIDs - List of nodeIDs to blacklist * @returns {Function} */ blacklist: require('./blacklist'), /** * Creates a whitelist filter for accepting messages from defined nodeIDs * @function * @param {Array} nodeIDs - List of nodeIDs to whitelist * @returns {Function} */ whitelist: require('./whitelist'), /** * Allows the definition of method handlers not defined by kademlia * @function * @param {Object} protocol - Hash map of &lt;method_name&gt;:&lt;handler_function&gt; * @returns {Function} */ protocol: require('./protocol') }; × Search results Close Documentation generated by JSDoc 3.4.3 using the DocStrap template. "},"lib_transports_index.js.html":{"id":"lib_transports_index.js.html","title":"Source: lib/transports/index.js","body":" KadTools Modules kadkad/constantskad/contactskad/hookskad/storagekad/transportskad/utils Classes AddressPortContactBucketContactHTTPTransportItemLoggerMessagekad/storage.FSkad/storage.LocalStoragekad/storage.MemStoreNodeRouterRPCTCPTransportUDPTransport Events HTTPTransport#event:CONTACT_SEENHTTPTransport#event:FIND_NODEHTTPTransport#event:FIND_VALUEHTTPTransport#event:MESSAGE_DROPHTTPTransport#event:PINGHTTPTransport#event:readyHTTPTransport#event:STOREHTTPTransport#event:TIMEOUTNode#event:connectNode#event:disconnectNode#event:errorNode#event:joinNode#event:leaveRouter#event:addRouter#event:dropRouter#event:shiftRPC#event:CONTACT_SEENRPC#event:FIND_NODERPC#event:FIND_VALUERPC#event:MESSAGE_DROPRPC#event:PINGRPC#event:readyRPC#event:STORERPC#event:TIMEOUTTCPTransport#event:CONTACT_SEENTCPTransport#event:FIND_NODETCPTransport#event:FIND_VALUETCPTransport#event:MESSAGE_DROPTCPTransport#event:PINGTCPTransport#event:readyTCPTransport#event:STORETCPTransport#event:TIMEOUTUDPTransport#event:CONTACT_SEENUDPTransport#event:FIND_NODEUDPTransport#event:FIND_VALUEUDPTransport#event:MESSAGE_DROPUDPTransport#event:PINGUDPTransport#event:readyUDPTransport#event:STOREUDPTransport#event:TIMEOUT Tutorials Custom ContactsCustom Storage AdaptersCustom Transport AdaptersProtocol SpecificationUsing Hooks Externals kad-fskad-localstoragekad-memstore Source: lib/transports/index.js /** * @module kad/transports */ 'use strict'; module.exports = { /** {@link TCPTransport} */ TCP: require('./tcp'), /** {@link UDPTransport} */ UDP: require('./udp'), /** {@link HTTPTransport} */ HTTP: require('./http') }; × Search results Close Documentation generated by JSDoc 3.4.3 using the DocStrap template. "},"lib_utils.js.html":{"id":"lib_utils.js.html","title":"Source: lib/utils.js","body":" KadTools Modules kadkad/constantskad/contactskad/hookskad/storagekad/transportskad/utils Classes AddressPortContactBucketContactHTTPTransportItemLoggerMessagekad/storage.FSkad/storage.LocalStoragekad/storage.MemStoreNodeRouterRPCTCPTransportUDPTransport Events HTTPTransport#event:CONTACT_SEENHTTPTransport#event:FIND_NODEHTTPTransport#event:FIND_VALUEHTTPTransport#event:MESSAGE_DROPHTTPTransport#event:PINGHTTPTransport#event:readyHTTPTransport#event:STOREHTTPTransport#event:TIMEOUTNode#event:connectNode#event:disconnectNode#event:errorNode#event:joinNode#event:leaveRouter#event:addRouter#event:dropRouter#event:shiftRPC#event:CONTACT_SEENRPC#event:FIND_NODERPC#event:FIND_VALUERPC#event:MESSAGE_DROPRPC#event:PINGRPC#event:readyRPC#event:STORERPC#event:TIMEOUTTCPTransport#event:CONTACT_SEENTCPTransport#event:FIND_NODETCPTransport#event:FIND_VALUETCPTransport#event:MESSAGE_DROPTCPTransport#event:PINGTCPTransport#event:readyTCPTransport#event:STORETCPTransport#event:TIMEOUTUDPTransport#event:CONTACT_SEENUDPTransport#event:FIND_NODEUDPTransport#event:FIND_VALUEUDPTransport#event:MESSAGE_DROPUDPTransport#event:PINGUDPTransport#event:readyUDPTransport#event:STOREUDPTransport#event:TIMEOUT Tutorials Custom ContactsCustom Storage AdaptersCustom Transport AdaptersProtocol SpecificationUsing Hooks Externals kad-fskad-localstoragekad-memstore Source: lib/utils.js /** * @module kad/utils */ 'use strict'; var assert = require('assert'); var crypto = require('crypto'); var constants = require('./constants'); /** * Validate a key * @param {String} key - Key to test * @returns {Boolean} */ exports.isValidKey = function(key) { return !!key &amp;&amp; key.length === constants.B / 4; }; /** * Create a valid ID from the given string * @param {String|Buffer} data - Data to SHA1 hash * @returns {String} */ exports.createID = function(data) { if (exports.isValidKey(data)) { return data; } return crypto.createHash('sha1').update(data).digest('hex'); }; /** * Convert a key to a buffer * @param {String} hexString * @returns {Buffer} */ exports.hexToBuffer = function(hexString) { var buf = new Buffer(constants.B / 8); buf.write(hexString, 0, 'hex'); return buf; }; /** * Calculate the distance between two keys * @param {String} key1 * @param {String} key2 * @returns {Number} */ exports.getDistance = function(id1, id2) { assert(exports.isValidKey(id1), 'Invalid key supplied'); assert(exports.isValidKey(id2), 'Invalid key supplied'); var distance = new Buffer(constants.B / 8); var id1Buf = exports.hexToBuffer(id1); var id2Buf = exports.hexToBuffer(id2); for(var i = 0; i &lt; constants.B / 8; ++i) { distance[i] = id1Buf[i] ^ id2Buf[i]; } return distance; }; /** * Compare two buffers for sorting * @param {Buffer} b1 * @param {Buffer} b2 * @returns {Number} */ exports.compareKeys = function(b1, b2) { assert.equal(b1.length, b2.length); for (var i = 0; i &lt; b1.length; ++i) { if (b1[i] !== b2[i]) { if (b1[i] &lt; b2[i]) { return -1; } else { return 1; } } } return 0; }; /** * Calculate the index of the bucket that key would belong to * @param {String} id1 * @param {String} id2 * @returns {Number} */ exports.getBucketIndex = function(id1, id2) { assert(exports.isValidKey(id1), 'Invalid key supplied'); assert(exports.isValidKey(id2), 'Invalid key supplied'); var distance = exports.getDistance(id1, id2); var bucketNum = constants.B; for (var i = 0; i &lt; distance.length; i++) { if (distance[i] === 0) { bucketNum -= 8; continue; } for (var j = 0; j &lt; 8; j++) { if (distance[i] &amp; (0x80 &gt;&gt; j)) { return --bucketNum; } else { bucketNum--; } } } return bucketNum; }; /** * @private * @param {Number} exp * @returns {Buffer} */ exports.getPowerOfTwoBuffer = function(exp) { assert.ok(exp &gt;= 0 &amp;&amp; exp &lt; constants.B); var buffer = new Buffer(constants.K); var byte = parseInt(exp / 8); // we set the byte containing the bit to the right left shifted amount buffer.fill(0); buffer[constants.K - byte - 1] = 1 &lt;&lt; (exp % 8); return buffer; }; /** * Assuming index corresponds to power of 2 * (index = n has nodes within distance 2^n &lt;= distance &lt; 2^(n+1)) * @param {Number} index */ exports.getRandomInBucketRangeBuffer = function(index) { var base = exports.getPowerOfTwoBuffer(index); var byte = parseInt(index / 8); // randomize bytes below the power of two for (var i = constants.K - 1; i &gt; (constants.K - byte - 1); i--) { base[i] = parseInt(Math.random() * 256); } // also randomize the bits below the number in that byte // and remember arrays are off by 1 for (var j = index - 1; j &gt;= byte * 8; j--) { var one = Math.random() &gt;= 0.5; var shiftAmount = j - byte * 8; base[constants.K - byte - 1] |= one ? (1 &lt;&lt; shiftAmount) : 0; } return base; }; × Search results Close Documentation generated by JSDoc 3.4.3 using the DocStrap template. "},"lib_node.js.html":{"id":"lib_node.js.html","title":"Source: lib/node.js","body":" KadTools Modules kadkad/constantskad/contactskad/hookskad/storagekad/transportskad/utils Classes AddressPortContactBucketContactHTTPTransportItemLoggerMessagekad/storage.FSkad/storage.LocalStoragekad/storage.MemStoreNodeRouterRPCTCPTransportUDPTransport Events HTTPTransport#event:CONTACT_SEENHTTPTransport#event:FIND_NODEHTTPTransport#event:FIND_VALUEHTTPTransport#event:MESSAGE_DROPHTTPTransport#event:PINGHTTPTransport#event:readyHTTPTransport#event:STOREHTTPTransport#event:TIMEOUTNode#event:connectNode#event:disconnectNode#event:errorNode#event:joinNode#event:leaveRouter#event:addRouter#event:dropRouter#event:shiftRPC#event:CONTACT_SEENRPC#event:FIND_NODERPC#event:FIND_VALUERPC#event:MESSAGE_DROPRPC#event:PINGRPC#event:readyRPC#event:STORERPC#event:TIMEOUTTCPTransport#event:CONTACT_SEENTCPTransport#event:FIND_NODETCPTransport#event:FIND_VALUETCPTransport#event:MESSAGE_DROPTCPTransport#event:PINGTCPTransport#event:readyTCPTransport#event:STORETCPTransport#event:TIMEOUTUDPTransport#event:CONTACT_SEENUDPTransport#event:FIND_NODEUDPTransport#event:FIND_VALUEUDPTransport#event:MESSAGE_DROPUDPTransport#event:PINGUDPTransport#event:readyUDPTransport#event:STOREUDPTransport#event:TIMEOUT Tutorials Custom ContactsCustom Storage AdaptersCustom Transport AdaptersProtocol SpecificationUsing Hooks Externals kad-fskad-localstoragekad-memstore Source: lib/node.js 'use strict'; var merge = require('merge'); var assert = require('assert'); var async = require('async'); var inherits = require('util').inherits; var events = require('events'); var constants = require('./constants'); var Router = require('./router'); var Message = require('./message'); var Item = require('./item'); var Logger = require('./logger'); /** * Represents a Kademlia node * @constructor * @param {Object} options * @param {Router} options.router - Custom router instance to use * @param {RPC} options.transport - Transport (RPC) adapter to use * @param {Object} options.storage - Storage adapter to use * @param {Logger} options.logger - Logger instance to use * @param {Node~validator} options.validator - Key-Value validation function * @emits Node#join * @emits Node#leave * @emits Node#connect * @emits Node#disconnect * @emits Node#error */ function Node(options) { options = merge(Object.create(Node.DEFAULTS), options); if (!(this instanceof Node)) { return new Node(options); } events.EventEmitter.call(this); this._setStorageAdapter(options.storage); this._log = options.logger; this._rpc = options.transport; this._self = this._rpc._contact; this._validator = options.validator; this._router = options.router || new Router({ logger: this._log, transport: this._rpc, validator: this._validateKeyValuePair.bind(this) }); this._bindRouterEventHandlers(); this._bindRPCMessageHandlers(); this._startReplicationInterval(); this._startExpirationInterval(); this._log.info('node created with nodeID %s', this._self.nodeID); } /** * Called when a value is retrieved or stored to validate the pair * @callback Node~validator * @param {String} key - The key at which the value is or should be stored * @param {String} value - The returned or stored value * @param {Function} callback - Called with boolean indicating validity */ /** * Join event is triggered when the routing table is no longer empty * @event Node#join */ /** * Leave event is triggered when the routing table becomes empty * @event Node#leave */ /** * Aliases {@link Node#event:join} for backwards compatibility; use one or the * other, but not both * @deprecated since version 1.4.0, use {@link Node#event:join} instead * @event Node#connect */ /** * Aliases {@link Node#event:leave} for backwards compatibility; use one or the * other, but not both * @deprecated since version 1.4.0, use {@link Node#event:leave} instead * @event Node#disconnect */ /** * Error event fires when a critical failure has occurred; if no handler is * specified, then it will throw * @event Node#error * @type {Error} */ inherits(Node, events.EventEmitter); Node.DEFAULTS = { logger: new Logger(4) }; /** * Connects to the overlay network * @param {Contact} contact - Contact object to use for entering network * @param {Node~connectCallback} callback - Optional callback on connect * @returns {Node} */ Node.prototype.connect = function(contact, callback) { var self = this; var seed = this._rpc._createContact(contact); var done = callback || function() {}; this._log.debug('entering overlay network via %j', seed); async.waterfall([ this._ensureTransportState.bind(this), function(next) { self._router.updateContact(seed, function() { next(); }); }, this._router.findNode.bind(this._router, this._self.nodeID, { aggressiveLookup: true, aggressiveCache: true }), this._router.refreshBucketsBeyondClosest.bind(this._router) ], function(err) { if (err) { return done(err); } done.call(self, null, contact); }); return this; }; /** * This callback is called upon completion of {@link Node#connect} * @callback Node~connectCallback * @param {Error|null} err - The error object, if any * @param {Contact} contact - The {@link Contact} passed to {@link Node#connect} */ /** * Disconnects from the overlay by closing the transport and emptying the * routing table * @param {Node~disconnectCallback} callback - Optional callback on disconnect */ Node.prototype.disconnect = function(callback) { var self = this; var done = callback || function() {}; if (this._rpc.readyState === 0) { return done(); } this._rpc.close(function() { self._router.empty(); self.emit('leave'); done(); }); }; /** * This callback is called upon completion of {@link Node#disconnect} * @callback Node~disconnectCallback */ /** * Set a key/value pair in the DHT * @param {String} key - Lookup key for the value to store * @param {String} value - Data to store in the DHT * @param {Node~putCallback} callback - Executed upon completion */ Node.prototype.put = function(key, value, callback) { var node = this; this._log.debug('attempting to set value for key %s', key); this._validateKeyValuePair(key, value, function(valid) { if (!valid) { node._log.warn('failed to validate key/value pair for %s', key); return callback(new Error('Failed to validate key/value pair')); } node._putValidatedKeyValue(Item(key, value, node._self.nodeID), callback); }); }; /** * This callback is called upon completion of {@link Node#put} * @callback Node~putCallback * @param {Error|null} err - The error object, if any */ /** * Get a value by it's key from the DHT * @param {String} key - Lookup key for the stored value * @param {Function} callback */ Node.prototype.get = function(key, callback) { var self = this; this._log.debug('attempting to get value for key %s', key); self._router.findValue(key, function(err, value) { if (err) { self._log.warn('failed to get value from peers, reason: %s', err.message); self._log.info('checking local storage for items at key %s', key); return self._storage.get(key, function(err, item) { if (!err &amp;&amp; item) { callback(null, JSON.parse(item).value); } else { callback(err); } }); } callback(null, value); }); }; /** * This callback is called upon completion of {@link Node#get} * @callback Node~getCallback * @param {Error|null} err - The error object, if any * @param {String} value - The value retrieved from the DHT */ /** * Set a validated key/value pair in the DHT * @private * @param {Item} item * @param {Function} callback */ Node.prototype._putValidatedKeyValue = function(item, callback) { var node = this; this._router.findNode(item.key, function(err, contacts) { if (err) { node._log.warn('failed to find nodes, reason: %s', err.message); node._log.info('saving item to local storage'); return node._storage.put(item.key, JSON.stringify(item), callback); } if (contacts.length === 0) { node._log.warn('no contacts returned, checking local table...'); contacts = node._router.getNearestContacts( item.key, constants.K, node._self.nodeID ); } node._log.debug('found %d contacts for STORE operation', contacts.length); async.each(contacts, function(contact, done) { var message = new Message({ method: 'STORE', params: { item: item, contact: node._self } }); node._log.debug('sending STORE message to %j', contact); node._rpc.send(contact, message, done); }, function(err) { if (err) { node._log.error( 'Failed to store value at one or more nodes, reason:', err.message ); } // NB: Always store a local copy so we can republish later node._storage.put(item.key, JSON.stringify(item), callback); }); }); }; /** * Validate a key/value pair (defaults to always valid). * @private * @param {String} key * @param {String} value * @param {Function} callback */ Node.prototype._validateKeyValuePair = function(key, value, callback) { if (typeof this._validator === 'function') { return this._validator.apply(this, arguments); } callback(true); }; /** * Setup event listeners from the router for determining status of the node * in the overlay network * @private */ Node.prototype._bindRouterEventHandlers = function() { var self = this; this.connected = false; this.on('join', function() { this.connected = true; }); this.on('leave', function() { this.connected = false; }); function checkRouterStatus(contact) { if (self._router.length) { self.emit('join', contact); self.emit('connect', contact); } else { self.emit('leave', contact); self.emit('disconnect', contact); } } this._router.on('add', checkRouterStatus); this._router.on('remove', checkRouterStatus); }; /** * Ensures that the transport adapter is in an open state * @private * @param {Function} callback */ Node.prototype._ensureTransportState = function(callback) { if (this._rpc.readyState === 2) { return callback(); } if (this._rpc.readyState === 1) { return this._rpc.on('ready', callback); } this._rpc.open(callback); }; /** * Setup event listeners for rpc messages * @private */ Node.prototype._bindRPCMessageHandlers = function() { var self = this; this._rpc.on('PING', this._handlePing.bind(this)); this._rpc.on('STORE', this._handleStore.bind(this)); this._rpc.on('FIND_NODE', this._handleFindNode.bind(this)); this._rpc.on('FIND_VALUE', this._handleFindValue.bind(this)); this._rpc.on('CONTACT_SEEN', this._router.updateContact.bind(this._router)); this._rpc.on('TIMEOUT', this._router.removeContact.bind(this._router)); this._rpc.on('ready', function() { self._log.debug('node listening on %j', self._self.toString()); }); }; /** * Replicate local storage every T_REPLICATE * @private */ Node.prototype._startReplicationInterval = function() { setInterval(this._replicate.bind(this), constants.T_REPLICATE); }; /** * Replicate local storage * @private */ Node.prototype._replicate = function() { var self = this; var stream = this._storage.createReadStream(); this._log.info('starting local database replication'); stream.on('data', function(data) { var item = null; var parsed = null; try { parsed = JSON.parse(data.value); item = Item(data.key, parsed.value, parsed.publisher, parsed.timestamp); } catch(err) { return self._log.error('failed to parse value from %s', data.value); } /* istanbul ignore else */ // if we are not the publisher, then replicate every T_REPLICATE if (item.publisher !== self._self.nodeID) { self._putValidatedKeyValue(item, function(err) { if (err) { self._log.error('failed to replicate item at key %s', data.key); } }); // if we are the publisher, then only replicate every T_REPUBLISH } else if (Date.now() &gt;= item.timestamp + constants.T_REPUBLISH) { self.put(item.key, item.value, function(err) { if (err) { self._log.error('failed to republish item at key %s', data.key); } }); } }); stream.on('error', function(err) { self._log.error('error while replicating: %s', err.message); }); stream.on('end', function() { self._log.info('database replication complete'); }); }; /** * Expire entries older than T_EXPIRE * @private */ Node.prototype._startExpirationInterval = function() { setInterval(this._expire.bind(this), constants.T_EXPIRE); }; /** * Expire entries older than T_EXPIRE * @private */ Node.prototype._expire = function() { var self = this; var stream = this._storage.createReadStream(); this._log.info('starting local database expiration'); stream.on('data', function(data) { var item = null; var parsed = null; try { parsed = JSON.parse(data.value); item = Item(data.key, parsed.value, parsed.publisher, parsed.timestamp); } catch(err) { return self._log.error('failed to parse value from %s', data.value); } if (Date.now() &gt;= item.timestamp + constants.T_EXPIRE) { self._storage.del(data.key, function(err) { /* istanbul ignore next */ if (err) { self._log.error('failed to expire item at key %s', data.key); } }); } }); stream.on('error', function(err) { self._log.error('error while expiring: %s', err.message); }); stream.on('end', function() { self._log.info('database expiration complete'); }); }; /** * Handle PING RPC message * @private * @param {Message} incomingMsg */ Node.prototype._handlePing = function(incomingMsg) { var contact = this._rpc._createContact(incomingMsg.params.contact); var message = new Message({ id: incomingMsg.id, result: { contact: this._self } }); this._log.info( 'received PING from %s, sending PONG', incomingMsg.params.contact.nodeID ); this._rpc.send(contact, message); }; /** * Handle STORE RPC message * @private * @param {Message} incomingMsg */ Node.prototype._handleStore = function(incomingMsg) { var node = this; var params = incomingMsg.params; var item = params.item; try { item = new Item(item.key, item.value, item.publisher); } catch(err) { return this._log.error( 'failed to store item at key %s, reason: %s', item.key, err.message ); } this._log.info('received valid STORE from %s', params.contact.nodeID); this._validateKeyValuePair(item.key, item.value, function(valid) { if (!valid) { node._log.warn('failed to validate key/value pair for %s', item.key); return; } node._storeValidatedKeyValue(item, incomingMsg); }); }; /** * Add the validated key/value to storage * @private * @param {Item} item * @param {Message} incomingMsg */ Node.prototype._storeValidatedKeyValue = function(item, incomingMsg) { var node = this; var params = incomingMsg.params; this._storage.put(item.key, JSON.stringify(item), function(err) { var contact = node._rpc._createContact(incomingMsg.params.contact); var message = new Message({ error: err, result: { contact: node._self }, id: incomingMsg.id }); if (err) { node._log.warn('store failed, notifying %s', params.contact.nodeID); } else { node._log.debug('successful store, notifying %s', params.contact.nodeID); } node._rpc.send(contact, message); }); }; /** * Handle FIND_NODE RPC message * @private * @param {Message} incomingMsg */ Node.prototype._handleFindNode = function(incomingMsg) { this._log.info('received FIND_NODE from %j', incomingMsg.params.contact); var node = this; var params = incomingMsg.params; var contact = this._rpc._createContact(params.contact); var near = this._router.getNearestContacts( params.key, constants.K, params.contact.nodeID ); var message = new Message({ id: incomingMsg.id, result: { nodes: near, contact: node._self } }); this._log.debug( 'sending %s nearest %d contacts', params.contact.nodeID, near.length ); this._rpc.send(contact, message); }; /** * Handle FIND_VALUE RPC message * @private * @param {Message} incomingMsg */ Node.prototype._handleFindValue = function(incomingMsg) { var node = this; var params = incomingMsg.params; var contact = this._rpc._createContact(params.contact); var limit = constants.K; this._log.info('received valid FIND_VALUE from %s', params.contact.nodeID); this._storage.get(params.key, function(err, value) { if (err || !value) { node._log.debug( 'value not found, sending contacts to %s', params.contact.nodeID ); var notFoundMessage = new Message({ id: incomingMsg.id, result: { nodes: node._router.getNearestContacts( params.key, limit, params.contact.nodeID ), contact: node._self } }); return node._rpc.send(contact, notFoundMessage); } var parsed = JSON.parse(value); var item = new Item( parsed.key, parsed.value, parsed.publisher, parsed.timestamp ); node._log.debug('found value, sending to %s', params.contact.nodeID); var foundMessage = new Message({ id: incomingMsg.id, result: { item: item, contact: node._self } }); node._rpc.send(contact, foundMessage); }); }; /** * Validates the set storage adapter * @private * @param {Object} storage */ Node.prototype._setStorageAdapter = function(storage) { assert(typeof storage === 'object', 'No storage adapter supplied'); assert(typeof storage.get === 'function', 'Store has no get method'); assert(typeof storage.put === 'function', 'Store has no put method'); assert(typeof storage.del === 'function', 'Store has no del method'); assert( typeof storage.createReadStream === 'function', 'Store has no createReadStream method' ); this._storage = storage; }; module.exports = Node; × Search results Close Documentation generated by JSDoc 3.4.3 using the DocStrap template. "},"lib_router.js.html":{"id":"lib_router.js.html","title":"Source: lib/router.js","body":" KadTools Modules kadkad/constantskad/contactskad/hookskad/storagekad/transportskad/utils Classes AddressPortContactBucketContactHTTPTransportItemLoggerMessagekad/storage.FSkad/storage.LocalStoragekad/storage.MemStoreNodeRouterRPCTCPTransportUDPTransport Events HTTPTransport#event:CONTACT_SEENHTTPTransport#event:FIND_NODEHTTPTransport#event:FIND_VALUEHTTPTransport#event:MESSAGE_DROPHTTPTransport#event:PINGHTTPTransport#event:readyHTTPTransport#event:STOREHTTPTransport#event:TIMEOUTNode#event:connectNode#event:disconnectNode#event:errorNode#event:joinNode#event:leaveRouter#event:addRouter#event:dropRouter#event:shiftRPC#event:CONTACT_SEENRPC#event:FIND_NODERPC#event:FIND_VALUERPC#event:MESSAGE_DROPRPC#event:PINGRPC#event:readyRPC#event:STORERPC#event:TIMEOUTTCPTransport#event:CONTACT_SEENTCPTransport#event:FIND_NODETCPTransport#event:FIND_VALUETCPTransport#event:MESSAGE_DROPTCPTransport#event:PINGTCPTransport#event:readyTCPTransport#event:STORETCPTransport#event:TIMEOUTUDPTransport#event:CONTACT_SEENUDPTransport#event:FIND_NODEUDPTransport#event:FIND_VALUEUDPTransport#event:MESSAGE_DROPUDPTransport#event:PINGUDPTransport#event:readyUDPTransport#event:STOREUDPTransport#event:TIMEOUT Tutorials Custom ContactsCustom Storage AdaptersCustom Transport AdaptersProtocol SpecificationUsing Hooks Externals kad-fskad-localstoragekad-memstore Source: lib/router.js 'use strict'; var assert = require('assert'); var inherits = require('util').inherits; var events = require('events'); var async = require('async'); var _ = require('lodash'); var constants = require('./constants'); var utils = require('./utils'); var Message = require('./message'); var Logger = require('./logger'); var Bucket = require('./bucket'); var Contact = require('./contact'); var Item = require('./item'); /** * Represents a routing table of known {@link Contact}s; used by {@link Node}. * @constructor * @param {Object} options * @param {Logger} options.logger - Logger instance to use * @param {RPC} options.transport - Transport adapter (RPC) to use * @param {Router~validator} options.validator - Key-Value validation function * @emits Router#add * @emits Router#drop * @emits Router#shift */ function Router(options) { if (!(this instanceof Router)) { return new Router(options); } this._log = options.logger || new Logger(4); this._buckets = {}; this._rpc = options.transport; this._self = this._rpc._contact; this._validator = options.validator; Object.defineProperty(this, 'length', { get: this._getSize.bind(this), enumerable: false, configurable: false }); } /** * Called when a value is returned from a lookup to validate it * @callback Router~validator * @param {String} key - The key at which the value is stored * @param {String} value - The returned value from the lookup * @param {Function} callback - Called with boolean indicating validity */ /** * Add event is triggered when a new {@link Contact} is added to the router * @event Router#add */ /** * Drop event is triggered when a {@link Contact} is dropped from the router * @event Router#drop */ /** * Shift event is triggered when a {@link Contact} changes position in a * {@link Bucket} * @event Router#shift */ // NB: Don't ping contact at bucket head if seen within the last 5 minutes Router.PING_TTL = 300000; inherits(Router, events.EventEmitter); /** * Execute this router's find operation with the shortlist * @param {String} type - One of &quot;NODE&quot; or &quot;VALUE&quot; * @param {String} key - Key to use for lookup * @param {Router~lookupCallback} callback - Called when the lookup is complete * @param {Boolean} [aggressiveLookup=false] - Iterate until K contacts are * found even if there is no improvement */ Router.prototype.lookup = function(type, key, callback, aggressiveLookup) { assert(['NODE', 'VALUE'].indexOf(type) !== -1, 'Invalid search type'); var state = this._createLookupState(type, key, { aggressiveLookup: aggressiveLookup }); if (!state.closestNode) { return callback(new Error('Not connected to any peers')); } state.closestNodeDistance = utils.getDistance( state.hashedKey, state.closestNode.nodeID ); this._log.debug('performing network walk for %s %s', type, key); this._iterativeFind(state, state.shortlist, callback); }; /** * This callback is called upon completion of {@link Router#lookup} * @callback Router~lookupCallback * @param {Error|null} err - The error object, if any * @param {String} type - One of &quot;NODE&quot; or &quot;VALUE&quot; * @param {Array|String} result - The {@link Contact}s returned or the value */ /** * Returns the number of contacts in the routing table - used as the getter for * the Router#length property * @private */ Router.prototype._getSize = function() { var total = 0; for (var k in this._buckets) { total += this._buckets[k].getSize(); } return total; }; /** * Empties the routing table, clearing all known contacts */ Router.prototype.empty = function() { this._buckets = {}; this.emit('remove', this._self); }; /** * Removes the given contact from the routing table * @param {Contact} contact - The contact to drop from the router * @returns {Boolean} Operation succeeded (contact was in expected bucket) */ Router.prototype.removeContact = function(contact) { var index = utils.getBucketIndex(this._self.nodeID, contact.nodeID); var bucket = this._buckets[index]; this._log.debug('removing contact %j', contact); assert(index &lt; constants.B, 'Bucket index may not exceed B'); if (!bucket) { return false; } bucket.removeContact(contact); this.emit('drop', contact, bucket, bucket.indexOf(contact)); return true; }; /** * Returns the {@link Contact} in the routing table by the given node ID * @param {String} nodeID - The nodeID of the {@link Contact} to return * @returns {Contact|null} */ Router.prototype.getContactByNodeID = function(nodeID) { for (var k in this._buckets) { var contacts = this._buckets[k].getContactList(); for (var i = 0; i &lt; contacts.length; i++) { if (nodeID === contacts[i].nodeID) { return contacts[i]; } } } return null; }; /** * Creates a state machine for a lookup operation * @private * @param {String} type - One of 'NODE' or 'VALUE' * @param {String} key - 160 bit key * @param {Object} options * @param {Boolean} [options.aggressiveLookup=false] - Iterate until K contacts * are found even if there is no improvement * @returns {Object} Lookup state machine */ Router.prototype._createLookupState = function(type, key, options) { options = typeof options !== 'object' ? {} : options; var state = { type: type, key: key, hashedKey: utils.createID(key), limit: constants.ALPHA, previousClosestNode: null, contacted: {}, foundValue: false, value: null, contactsWithoutValue: [], aggressiveLookup: !!options.aggressiveLookup, completedIterations: 0 }; state.shortlist = this.getNearestContacts( key, state.limit, this._self.nodeID ); state.closestNode = state.shortlist[0]; return state; }; /** * Execute the find operation for this router type * @private * @param {Object} state - State machine returned from _createLookupState() * @param {Array} contacts - List of contacts to query * @param {Function} callback */ Router.prototype._iterativeFind = function(state, contacts, callback) { var self = this; var failures = 0; function queryContact(contact, next) { self._queryContact(state, contact, function(err) { if (err) { failures++; } next(); }); } this._log.debug('starting contact iteration for key %s', state.key); async.each(contacts, queryContact, function() { self._log.debug('finished iteration, handling results'); if (failures === contacts.length) { return callback(new Error('Lookup operation failed to return results')); } self._handleQueryResults(state, callback); }); }; /** * Send this router's RPC message to the contact * @private * @param {Object} state - State machine returned from _createLookupState() * @param {Contact} contact - Contact to query * @param {Function} callback */ Router.prototype._queryContact = function(state, contactInfo, callback) { var self = this; var contact = this._rpc._createContact(contactInfo); var message = new Message({ method: 'FIND_' + state.type, params: { key: state.key, contact: this._self } }); this._log.debug('querying %s for key %s', contact.nodeID, state.key); this._rpc.send(contact, message, function(err, response) { if (err) { self._log.warn( 'query failed, removing contact for shortlist, reason %s', err.message ); self._removeFromShortList(state, contact.nodeID); self.removeContact(contact); return callback(err); } self._handleFindResult(state, response, contact, callback); }); }; /** * Handle the results of the contact query * @private * @param {Object} state - State machine returned from _createLookupState() * @param {Message} message - Received response to FIND_* RPC * @param {Contact} contact - Sender of the message * @param {Function} callback */ Router.prototype._handleFindResult = function(state, msg, contact, callback) { var distance = utils.getDistance(state.hashedKey, contact.nodeID); state.contacted[contact.nodeID] = this.updateContact(contact); if (utils.compareKeys(distance, state.closestNodeDistance) === -1) { state.previousClosestNode = state.closestNode; state.closestNode = contact; state.closestNodeDistance = distance; } if (state.type === 'NODE') { this._addToShortList(state, msg.result.nodes); return callback(); } if (!msg.result.item) { state.contactsWithoutValue.push(contact); this._addToShortList(state, msg.result.nodes); return callback(); } this._validateFindResult(state, msg, contact, callback); }; /** * Validates the data returned from a find * @private * @param {Object} state - State machine returned from _createLookupState() * @param {Message} message - Received response to FIND_* RPC * @param {Contact} contact - Sender of the message * @param {Function} callback */ Router.prototype._validateFindResult = function(state, msg, contact, done) { var self = this; var item = msg.result.item; function rejectContact() { self._removeFromShortList(state, contact.nodeID); self.removeContact(contact); done(); } this._log.debug('validating result from %s', contact.nodeID); this._validateKeyValuePair(state.key, item.value, function(valid) { if (!valid) { self._log.warn('failed to validate key/value pair for %s', state.key); return rejectContact(); } state.foundValue = true; state.value = item.value; state.item = item; done(); }); }; /** * Add contacts to the shortlist, preserving nodeID uniqueness * @private * @param {Object} state - State machine returned from _createLookupState() * @param {Array} contacts - Contacts to add to the shortlist */ Router.prototype._addToShortList = function(state, contacts) { assert(Array.isArray(contacts), 'No contacts supplied'); state.shortlist = state.shortlist.concat(contacts); state.shortlist = _.uniq(state.shortlist, false, 'nodeID'); }; /** * Remove contacts with the nodeID from the shortlist * @private * @param {Object} state - State machine returned from _createLookupState() * @param {String} nodeID - Node ID of the contact to remove */ Router.prototype._removeFromShortList = function(state, nodeID) { state.shortlist = _.reject(state.shortlist, function(c) { return c.nodeID === nodeID; }); }; /** * Handle the results of all the executed queries * @private * @param {Object} state - State machine returned from _createLookupState() * @param {Function} callback */ Router.prototype._handleQueryResults = function(state, callback) { if (state.foundValue) { this._log.debug('a value was returned from query %s', state.key); return this._handleValueReturned(state, callback); } state.completedIterations++; var closestNodeUnchanged = state.closestNode === state.previousClosestNode; var shortlistFull = state.shortlist.length &gt;= constants.K; var shouldNotContinue = state.aggressiveLookup ? state.completedIterations === constants.ALPHA &amp;&amp; shortlistFull : (closestNodeUnchanged || shortlistFull); if (shouldNotContinue) { this._log.debug( 'shortlist is full or there are no known nodes closer to key %s', state.key ); return callback(null, 'NODE', state.shortlist); } var remainingContacts = _.reject(state.shortlist, function(c) { return state.contacted[c.nodeID]; }); if (remainingContacts.length === 0) { this._log.debug('there are no more remaining contacts to query'); return callback(null, 'NODE', state.shortlist); } this._log.debug('continuing with iterative query for key %s', state.key); this._iterativeFind( state, remainingContacts.splice(0, constants.ALPHA), callback ); }; /** * Handle a value being returned and store at closest nodes that didn't have it * @private * @param {Object} state - State machine returned from _createLookupState() * @param {Function} callback */ Router.prototype._handleValueReturned = function(state, callback) { var self = this; var distances = state.contactsWithoutValue.map(function(contact) { return { distance: utils.getDistance(contact.nodeID, self._self.nodeID), contact: contact }; }); distances.sort(function(a, b) { return utils.compareKeys(a.distance, b.distance); }); if (distances.length &gt;= 1) { var item = state.item; var closestWithoutValue = distances[0].contact; var message = new Message({ method: 'STORE', params: { item: new Item(item.key, item.value, item.publisher, item.timestamp), contact: this._self } }); this._rpc.send(closestWithoutValue, message); } callback(null, 'VALUE', state.value); }; /** * Refreshes the buckets farther than the closest known * @param {Array} contacts - Results returned from findNode() * @param {Router~refreshBeyondCallback} done - Called upon successful refresh */ Router.prototype.refreshBucketsBeyondClosest = function(contacts, done) { var bucketIndexes = Object.keys(this._buckets); var leastBucket = _.min(bucketIndexes); function bucketFilter(index) { return index &gt; leastBucket; } var refreshBuckets = bucketIndexes.filter(bucketFilter); var queue = async.queue(this.refreshBucket.bind(this), 1); this._log.debug('refreshing buckets farthest than closest known'); refreshBuckets.forEach(function(index) { queue.push(index); }); done(); }; /** * This callback is called upon completion of * {@link Router#refreshBucketsBeyondClosest} * @callback Router~refreshBeyondCallback */ /** * Refreshes the bucket at the given index * @param {Number} index * @param {Function} callback */ Router.prototype.refreshBucket = function(index, callback) { var random = utils.getRandomInBucketRangeBuffer(index); this.findNode(random.toString('hex'), { aggressiveCache: true }, callback); }; /** * This callback is called upon completion of {@link Router#refreshBucket} * @callback Router~refreshCallback * @param {Error|null} err - The error object, if any * @param {Array} contacts - The list of {@link Contact}s refreshed */ /** * Search contacts for the value at given key * @param {String} key - The lookup key for the desired value * @param {Router~findValueCallback} callback - Called upon lookup completion */ Router.prototype.findValue = function(key, callback) { var self = this; this._log.debug('searching for value at key %s', key); this.lookup('VALUE', key, function(err, type, value) { if (err || type === 'NODE') { return callback(new Error('Failed to find value for key: ' + key)); } self._log.debug('found value for key %s', key); callback(null, value); }); }; /** * This callback is called upon completion of {@link Router#findValue} * @callback Router~findValueCallback * @param {Error|null} err - The error object, if any * @param {String} value - The value returned from the lookup */ /** * Search contacts for nodes close to the given key * @param {String} nodeID - The nodeID the search for neighbors * @param {Object} [options] * @param {Boolean} [options.aggressiveLookup=false] - Iterate until K contacts * are found even if there is no improvement * @param {Boolean} [options.aggressiveCache=false] - Try to add all results * from any FIND_NODE RPC to the routing table * @param {Router~findNodeCallback} callback - Called upon lookup completion */ Router.prototype.findNode = function(nodeID, options, callback) { var self = this; if (typeof options === 'function') { callback = options; options = {}; } this._log.debug('searching for nodes close to key %s', nodeID); this.lookup('NODE', nodeID, function(err, type, contacts) { if (err) { return callback(err); } self._log.debug('found %d nodes close to key %s', contacts.length, nodeID); if (options.aggressiveCache) { contacts.forEach(function(contact) { self.updateContact(new self._self.constructor( JSON.parse(JSON.stringify(contact)) )); }); } callback(null, contacts); }, options.aggressiveLookup); }; /** * This callback is called upon completion of {@link Router#findNode} * @callback Router~findNodeCallback * @param {Error|null} err - The error object, if any * @param {Array} value - The {@link Contact}s returned from the lookup */ /** * Update the contact's status * @param {Contact} contact - Contact to update * @param {Router~updateContactCallback} callback - Optional completion calback * @returns {Contact} */ Router.prototype.updateContact = function(contact, callback) { var bucketIndex = utils.getBucketIndex(this._self.nodeID, contact.nodeID); this._log.debug('updating contact %j', contact); assert(bucketIndex &lt; constants.B, 'Bucket index cannot exceed B'); if (!this._buckets[bucketIndex]) { this._log.debug('creating new bucket for contact at index %d', bucketIndex); this._buckets[bucketIndex] = new Bucket(); } var bucket = this._buckets[bucketIndex]; var done = callback || function() {}; contact.seen(); if (bucket.hasContact(contact.nodeID)) { this._moveContactToTail(contact, bucket, done); } else if (bucket.getSize() &lt; constants.K) { this._moveContactToHead(contact, bucket, done); } else { this._pingContactAtHead(contact, bucket, done); } return contact; }; /** * This callback is called upon completion of {@link Router#updateContact} * @callback Router~updateContactCallback */ /** * Move the contact to the bucket's tail * @private * @param {Contact} contact * @param {Bucket} bucket * @param {Function} callback */ Router.prototype._moveContactToTail = function(contact, bucket, callback) { this._log.debug('contact already in bucket, moving to tail'); bucket.removeContact(contact); bucket.addContact(contact); this.emit('shift', contact, bucket, bucket.indexOf(contact)); callback(null, true); }; /** * Move the contact to the bucket's head * @private * @param {Contact} contact * @param {Bucket} bucket * @param {Function} callback */ Router.prototype._moveContactToHead = function(contact, bucket, callback) { this._log.debug('contact not in bucket, moving to head'); bucket.addContact(contact); this.emit('add', contact, bucket, bucket.indexOf(contact)); callback(null, true); }; /** * Ping the contact at head and if no response, replace with contact * @private * @param {Contact} contact * @param {Bucket} bucket * @param {Function} callback */ Router.prototype._pingContactAtHead = function(contact, bucket, callback) { var self = this; var ping = new Message({ method: 'PING', params: { contact: this._self } }); var head = bucket.getContact(0); if (!head) { return callback(null, false); // NB: Do nothing if no contact at head } // NB: Let's not DoS our head contact in the event that this bucket is // NB: very busy - instead let's check the last time we saw her and if // NB: we have communicated via other means with that contact and we // NB: do not need to ping her. if (Date.now() - head.lastSeen &lt; Router.PING_TTL) { return callback(null, false); } // NB: Prevent PING to death if a large update is applied to this bucket // NB: by pretending to have seen the head contact just now head.seen(); this._log.debug('no room in bucket, sending PING to contact at head'); this._rpc.send(head, ping, function(err) { if (err) { self._log.debug('head contact did not respond, replacing with new'); // NB: It's possible that the head contact has changed between pings // NB: timeout, so we need to make sure that we get the *most* stale // NB: contact. head = bucket.getContact(0) || head; bucket.removeContact(head); bucket.addContact(contact); self.emit('drop', head, bucket, bucket.indexOf(head)); self.emit('add', contact, bucket, bucket.indexOf(contact)); callback(null, true); } else { bucket.removeContact(head); bucket.addContact(head); callback(null, false); } }); }; /** * Return contacts closest to the given key * @param {String} key - Lookup key for getting close {@link Contact}s * @param {Number} limit - Maximum number of contacts to return * @param {String} nodeID - Node ID to exclude from results * @returns {Array} */ Router.prototype.getNearestContacts = function(key, limit, nodeID) { var self = this; var contacts = []; var index = utils.getBucketIndex(this._self.nodeID, utils.createID(key)); var ascBucketIndex = index; var descBucketIndex = index; function addNearestFromBucket(bucket) { self._getNearestFromBucket( bucket, utils.createID(key), limit - contacts.length ).forEach(function addToContacts(contact) { var isContact = contact instanceof Contact; var poolNotFull = contacts.length &lt; limit; var notRequester = contact.nodeID !== nodeID; if (isContact &amp;&amp; poolNotFull &amp;&amp; notRequester) { contacts.push(contact); } }); } addNearestFromBucket(this._buckets[index]); while (contacts.length &lt; limit &amp;&amp; ascBucketIndex &lt; constants.B) { ascBucketIndex++; addNearestFromBucket(this._buckets[ascBucketIndex]); } while (contacts.length &lt; limit &amp;&amp; descBucketIndex &gt;= 0) { descBucketIndex--; addNearestFromBucket(this._buckets[descBucketIndex]); } return contacts; }; /** * Get the contacts closest to the key from the given bucket * @private * @param {Bucket} bucket * @param {String} key * @param {Number} limit * @returns {Array} */ Router.prototype._getNearestFromBucket = function(bucket, key, limit) { if (!bucket) { return []; } var nearest = bucket.getContactList().map(function addDistance(contact) { return { contact: contact, distance: utils.getDistance(contact.nodeID, key) }; }).sort(function sortKeysByDistance(a, b) { return utils.compareKeys(a.distance, b.distance); }).splice(0, limit).map(function pluckContact(c) { return c.contact; }); return nearest; }; /** * Validates a key/value pair (defaults to true) * @private * @param {String} key * @param {String} value * @param {Function} callback */ Router.prototype._validateKeyValuePair = function(key, value, callback) { if (typeof this._validator === 'function') { return this._validator(key, value, callback); } callback(true); }; module.exports = Router; × Search results Close Documentation generated by JSDoc 3.4.3 using the DocStrap template. "},"lib_transports_tcp.js.html":{"id":"lib_transports_tcp.js.html","title":"Source: lib/transports/tcp.js","body":" KadTools Modules kadkad/constantskad/contactskad/hookskad/storagekad/transportskad/utils Classes AddressPortContactBucketContactHTTPTransportItemLoggerMessagekad/storage.FSkad/storage.LocalStoragekad/storage.MemStoreNodeRouterRPCTCPTransportUDPTransport Events HTTPTransport#event:CONTACT_SEENHTTPTransport#event:FIND_NODEHTTPTransport#event:FIND_VALUEHTTPTransport#event:MESSAGE_DROPHTTPTransport#event:PINGHTTPTransport#event:readyHTTPTransport#event:STOREHTTPTransport#event:TIMEOUTNode#event:connectNode#event:disconnectNode#event:errorNode#event:joinNode#event:leaveRouter#event:addRouter#event:dropRouter#event:shiftRPC#event:CONTACT_SEENRPC#event:FIND_NODERPC#event:FIND_VALUERPC#event:MESSAGE_DROPRPC#event:PINGRPC#event:readyRPC#event:STORERPC#event:TIMEOUTTCPTransport#event:CONTACT_SEENTCPTransport#event:FIND_NODETCPTransport#event:FIND_VALUETCPTransport#event:MESSAGE_DROPTCPTransport#event:PINGTCPTransport#event:readyTCPTransport#event:STORETCPTransport#event:TIMEOUTUDPTransport#event:CONTACT_SEENUDPTransport#event:FIND_NODEUDPTransport#event:FIND_VALUEUDPTransport#event:MESSAGE_DROPUDPTransport#event:PINGUDPTransport#event:readyUDPTransport#event:STOREUDPTransport#event:TIMEOUT Tutorials Custom ContactsCustom Storage AdaptersCustom Transport AdaptersProtocol SpecificationUsing Hooks Externals kad-fskad-localstoragekad-memstore Source: lib/transports/tcp.js 'use strict'; var assert = require('assert'); var inherits = require('util').inherits; var clarinet = require('clarinet'); var net = require('net'); var AddressPortContact = require('../contacts/address-port-contact'); var RPC = require('../rpc'); /** * Transport adapter that sends and receives messages over a TCP socket * @constructor * @extends {RPC} * @param {AddressPortContact} contact - Your node's {@link Contact} instance */ function TCPTransport(contact, options) { if (!(this instanceof TCPTransport)) { return new TCPTransport(contact, options); } assert(contact instanceof AddressPortContact, 'Invalid contact supplied'); RPC.call(this, contact, options); } inherits(TCPTransport, RPC); /** * Create a TCP socket and listen for messages * @private * @param {Function} done */ TCPTransport.prototype._open = function(done) { var self = this; this._socket = net.createServer(this._handleConnection.bind(this)); this._queuedResponses = {}; this._socket.on('error', function(err) { self._log.error('rpc encountered and error: %s', err.message); }); this._socket.on('listening', done); this._socket.listen(this._contact.port); }; /** * Send a RPC to the given contact * @private * @param {Buffer} data * @param {Contact} contact */ TCPTransport.prototype._send = function(data, contact) { var self = this; var parsed = JSON.parse(data.toString()); if (this._queuedResponses[parsed.id]) { this._queuedResponses[parsed.id].end(data); delete this._queuedResponses[parsed.id]; return; } if (!contact.valid()) { this._log.warn('Refusing to send message to invalid contact'); return this.receive(null); } var sock = net.createConnection(contact.port, contact.address); sock.on('error', function(err) { self._log.error('error connecting to peer', err); }); this._queuedResponses[parsed.id] = sock; this._handleConnection(sock); sock.write(data); }; /** * Close the underlying socket * @private */ TCPTransport.prototype._close = function() { this._socket.close(); }; /** * Handle incoming connection * @private * @param {Object} connection */ TCPTransport.prototype._handleConnection = function(connection) { var self = this; var parser = clarinet.createStream(); var buffer = ''; var opened = 0; var closed = 0; parser.on('openobject', function() { opened++; }); parser.on('closeobject', function() { closed++; if (opened === closed) { try { var parsed = JSON.parse(buffer); if (parsed.id &amp;&amp; !self._queuedResponses[parsed.id]) { self._queuedResponses[parsed.id] = connection; } } catch(err) { // noop } self.receive(new Buffer(buffer)); buffer = ''; opened = 0; closed = 0; } }); parser.on('error', function(err) { self._log.error(err.message); self._log.warn('failed to parse incoming message'); connection.end(); }); connection.on('error', function(err) { self._log.error(err.message); self._log.warn('error communicating with peer'); }); connection.on('data', function(data) { buffer += data.toString('utf8'); parser.write(data.toString('utf8')); }); }; module.exports = TCPTransport; × Search results Close Documentation generated by JSDoc 3.4.3 using the DocStrap template. "},"lib_transports_udp.js.html":{"id":"lib_transports_udp.js.html","title":"Source: lib/transports/udp.js","body":" KadTools Modules kadkad/constantskad/contactskad/hookskad/storagekad/transportskad/utils Classes AddressPortContactBucketContactHTTPTransportItemLoggerMessagekad/storage.FSkad/storage.LocalStoragekad/storage.MemStoreNodeRouterRPCTCPTransportUDPTransport Events HTTPTransport#event:CONTACT_SEENHTTPTransport#event:FIND_NODEHTTPTransport#event:FIND_VALUEHTTPTransport#event:MESSAGE_DROPHTTPTransport#event:PINGHTTPTransport#event:readyHTTPTransport#event:STOREHTTPTransport#event:TIMEOUTNode#event:connectNode#event:disconnectNode#event:errorNode#event:joinNode#event:leaveRouter#event:addRouter#event:dropRouter#event:shiftRPC#event:CONTACT_SEENRPC#event:FIND_NODERPC#event:FIND_VALUERPC#event:MESSAGE_DROPRPC#event:PINGRPC#event:readyRPC#event:STORERPC#event:TIMEOUTTCPTransport#event:CONTACT_SEENTCPTransport#event:FIND_NODETCPTransport#event:FIND_VALUETCPTransport#event:MESSAGE_DROPTCPTransport#event:PINGTCPTransport#event:readyTCPTransport#event:STORETCPTransport#event:TIMEOUTUDPTransport#event:CONTACT_SEENUDPTransport#event:FIND_NODEUDPTransport#event:FIND_VALUEUDPTransport#event:MESSAGE_DROPUDPTransport#event:PINGUDPTransport#event:readyUDPTransport#event:STOREUDPTransport#event:TIMEOUT Tutorials Custom ContactsCustom Storage AdaptersCustom Transport AdaptersProtocol SpecificationUsing Hooks Externals kad-fskad-localstoragekad-memstore Source: lib/transports/udp.js 'use strict'; var AddressPortContact = require('../contacts/address-port-contact'); var inherits = require('util').inherits; var assert = require('assert'); var dgram = require('dgram'); var RPC = require('../rpc'); /** * Transport adapter that sends and receives message over UDP * @constructor * @extends {RPC} * @param {Contact} contact - Your node's {@link Contact} instance */ function UDPTransport(contact, options) { if (!(this instanceof UDPTransport)) { return new UDPTransport(contact, options); } assert(contact instanceof AddressPortContact, 'Invalid contact supplied'); RPC.call(this, contact, options); } inherits(UDPTransport, RPC); UDPTransport.MAX_MESSAGE_SIZE = 512; // bytes /** * Create a UDP socket * @private * @param {function} done */ UDPTransport.prototype._open = function(done) { var self = this; function createSocket(port) { self._socket = dgram.createSocket( { type: 'udp4', reuseAddr: false }, self.receive.bind(self) ); self._socket.on('listening', done); self._socket.on('error', function(err) { self.emit('error', err); }); self._socket.bind(port); } createSocket(self._contact.port); }; /** * Send a RPC to the given contact (encode with msgpack before sending) * @private * @param {Buffer} data * @param {Contact} contact */ UDPTransport.prototype._send = function(data, contact) { if (data.length &gt; UDPTransport.MAX_MESSAGE_SIZE) { this._log.warn( 'outbound message greater than %sb (%sb) and risks fragmentation', UDPTransport.MAX_MESSAGE_SIZE, data.length ); } this._socket.send(data, 0, data.length, contact.port, contact.address); }; /** * Close the underlying socket * @private */ UDPTransport.prototype._close = function() { this._socket.close(); }; module.exports = UDPTransport; × Search results Close Documentation generated by JSDoc 3.4.3 using the DocStrap template. "},"modules.list.html":{"id":"modules.list.html","title":"Modules","body":" KadTools Modules kadkad/constantskad/contactskad/hookskad/storagekad/transportskad/utils Classes AddressPortContactBucketContactHTTPTransportItemLoggerMessagekad/storage.FSkad/storage.LocalStoragekad/storage.MemStoreNodeRouterRPCTCPTransportUDPTransport Events HTTPTransport#event:CONTACT_SEENHTTPTransport#event:FIND_NODEHTTPTransport#event:FIND_VALUEHTTPTransport#event:MESSAGE_DROPHTTPTransport#event:PINGHTTPTransport#event:readyHTTPTransport#event:STOREHTTPTransport#event:TIMEOUTNode#event:connectNode#event:disconnectNode#event:errorNode#event:joinNode#event:leaveRouter#event:addRouter#event:dropRouter#event:shiftRPC#event:CONTACT_SEENRPC#event:FIND_NODERPC#event:FIND_VALUERPC#event:MESSAGE_DROPRPC#event:PINGRPC#event:readyRPC#event:STORERPC#event:TIMEOUTTCPTransport#event:CONTACT_SEENTCPTransport#event:FIND_NODETCPTransport#event:FIND_VALUETCPTransport#event:MESSAGE_DROPTCPTransport#event:PINGTCPTransport#event:readyTCPTransport#event:STORETCPTransport#event:TIMEOUTUDPTransport#event:CONTACT_SEENUDPTransport#event:FIND_NODEUDPTransport#event:FIND_VALUEUDPTransport#event:MESSAGE_DROPUDPTransport#event:PINGUDPTransport#event:readyUDPTransport#event:STOREUDPTransport#event:TIMEOUT Tutorials Custom ContactsCustom Storage AdaptersCustom Transport AdaptersProtocol SpecificationUsing Hooks Externals kad-fskad-localstoragekad-memstore Modules Classes AddressPortContact Bucket Contact HTTPTransport Item Logger Message FS LocalStorage MemStore Node Router RPC TCPTransport UDPTransport Events CONTACT_SEEN Triggered when a contact is seen Parameters: Name Type Description contact Contact The contact that was just encountered Inherited From: RPC#event:CONTACT_SEEN Source: lib/rpc.js, line 47 FIND_NODE Triggered when a FIND_NODE RPC is received Parameters: Name Type Description message Message The message received Inherited From: RPC#event:FIND_NODE Source: lib/rpc.js, line 60 FIND_VALUE Triggered when a FIND_VALUE RPC message is received Parameters: Name Type Description message Message The message received Inherited From: RPC#event:FIND_VALUE Source: lib/rpc.js, line 66 MESSAGE_DROP Triggered when an invalid RPC message is dropped Parameters: Name Type Description message Buffer The raw invalid message received Inherited From: RPC#event:MESSAGE_DROP Source: lib/rpc.js, line 84 PING Triggered when a PING RPC message is received Parameters: Name Type Description message Message The message received Inherited From: RPC#event:PING Source: lib/rpc.js, line 72 ready Triggered when the underlying transport is open Inherited From: RPC#event:ready Source: lib/rpc.js, line 42 STORE Triggered when a STORE RPC message is received Parameters: Name Type Description message Message The message received Inherited From: RPC#event:STORE Source: lib/rpc.js, line 78 TIMEOUT Triggered when a RPC message times out Parameters: Name Type Description contact Contact The contact that did not respond message Message The message sent that timed out Inherited From: RPC#event:TIMEOUT Source: lib/rpc.js, line 53 connect Aliases Node#event:join for backwards compatibility; use one or the other, but not both Deprecated: since version 1.4.0, use Node#event:join instead Source: lib/node.js, line 74 disconnect Aliases Node#event:leave for backwards compatibility; use one or the other, but not both Deprecated: since version 1.4.0, use Node#event:leave instead Source: lib/node.js, line 81 error Error event fires when a critical failure has occurred; if no handler is specified, then it will throw Type: Error Source: lib/node.js, line 88 join Join event is triggered when the routing table is no longer empty Source: lib/node.js, line 64 leave Leave event is triggered when the routing table becomes empty Source: lib/node.js, line 69 add Add event is triggered when a new Contact is added to the router Source: lib/router.js, line 52 drop Drop event is triggered when a Contact is dropped from the router Source: lib/router.js, line 57 shift Shift event is triggered when a Contact changes position in a Bucket Source: lib/router.js, line 62 CONTACT_SEEN Triggered when a contact is seen Parameters: Name Type Description contact Contact The contact that was just encountered Source: lib/rpc.js, line 47 FIND_NODE Triggered when a FIND_NODE RPC is received Parameters: Name Type Description message Message The message received Source: lib/rpc.js, line 60 FIND_VALUE Triggered when a FIND_VALUE RPC message is received Parameters: Name Type Description message Message The message received Source: lib/rpc.js, line 66 MESSAGE_DROP Triggered when an invalid RPC message is dropped Parameters: Name Type Description message Buffer The raw invalid message received Source: lib/rpc.js, line 84 PING Triggered when a PING RPC message is received Parameters: Name Type Description message Message The message received Source: lib/rpc.js, line 72 ready Triggered when the underlying transport is open Source: lib/rpc.js, line 42 STORE Triggered when a STORE RPC message is received Parameters: Name Type Description message Message The message received Source: lib/rpc.js, line 78 TIMEOUT Triggered when a RPC message times out Parameters: Name Type Description contact Contact The contact that did not respond message Message The message sent that timed out Source: lib/rpc.js, line 53 CONTACT_SEEN Triggered when a contact is seen Parameters: Name Type Description contact Contact The contact that was just encountered Inherited From: RPC#event:CONTACT_SEEN Source: lib/rpc.js, line 47 FIND_NODE Triggered when a FIND_NODE RPC is received Parameters: Name Type Description message Message The message received Inherited From: RPC#event:FIND_NODE Source: lib/rpc.js, line 60 FIND_VALUE Triggered when a FIND_VALUE RPC message is received Parameters: Name Type Description message Message The message received Inherited From: RPC#event:FIND_VALUE Source: lib/rpc.js, line 66 MESSAGE_DROP Triggered when an invalid RPC message is dropped Parameters: Name Type Description message Buffer The raw invalid message received Inherited From: RPC#event:MESSAGE_DROP Source: lib/rpc.js, line 84 PING Triggered when a PING RPC message is received Parameters: Name Type Description message Message The message received Inherited From: RPC#event:PING Source: lib/rpc.js, line 72 ready Triggered when the underlying transport is open Inherited From: RPC#event:ready Source: lib/rpc.js, line 42 STORE Triggered when a STORE RPC message is received Parameters: Name Type Description message Message The message received Inherited From: RPC#event:STORE Source: lib/rpc.js, line 78 TIMEOUT Triggered when a RPC message times out Parameters: Name Type Description contact Contact The contact that did not respond message Message The message sent that timed out Inherited From: RPC#event:TIMEOUT Source: lib/rpc.js, line 53 CONTACT_SEEN Triggered when a contact is seen Parameters: Name Type Description contact Contact The contact that was just encountered Inherited From: RPC#event:CONTACT_SEEN Source: lib/rpc.js, line 47 FIND_NODE Triggered when a FIND_NODE RPC is received Parameters: Name Type Description message Message The message received Inherited From: RPC#event:FIND_NODE Source: lib/rpc.js, line 60 FIND_VALUE Triggered when a FIND_VALUE RPC message is received Parameters: Name Type Description message Message The message received Inherited From: RPC#event:FIND_VALUE Source: lib/rpc.js, line 66 MESSAGE_DROP Triggered when an invalid RPC message is dropped Parameters: Name Type Description message Buffer The raw invalid message received Inherited From: RPC#event:MESSAGE_DROP Source: lib/rpc.js, line 84 PING Triggered when a PING RPC message is received Parameters: Name Type Description message Message The message received Inherited From: RPC#event:PING Source: lib/rpc.js, line 72 ready Triggered when the underlying transport is open Inherited From: RPC#event:ready Source: lib/rpc.js, line 42 STORE Triggered when a STORE RPC message is received Parameters: Name Type Description message Message The message received Inherited From: RPC#event:STORE Source: lib/rpc.js, line 78 TIMEOUT Triggered when a RPC message times out Parameters: Name Type Description contact Contact The contact that did not respond message Message The message sent that timed out Inherited From: RPC#event:TIMEOUT Source: lib/rpc.js, line 53 × Search results Close Documentation generated by JSDoc 3.4.3 using the DocStrap template. "},"classes.list.html":{"id":"classes.list.html","title":"Classes","body":" KadTools Modules kadkad/constantskad/contactskad/hookskad/storagekad/transportskad/utils Classes AddressPortContactBucketContactHTTPTransportItemLoggerMessagekad/storage.FSkad/storage.LocalStoragekad/storage.MemStoreNodeRouterRPCTCPTransportUDPTransport Events HTTPTransport#event:CONTACT_SEENHTTPTransport#event:FIND_NODEHTTPTransport#event:FIND_VALUEHTTPTransport#event:MESSAGE_DROPHTTPTransport#event:PINGHTTPTransport#event:readyHTTPTransport#event:STOREHTTPTransport#event:TIMEOUTNode#event:connectNode#event:disconnectNode#event:errorNode#event:joinNode#event:leaveRouter#event:addRouter#event:dropRouter#event:shiftRPC#event:CONTACT_SEENRPC#event:FIND_NODERPC#event:FIND_VALUERPC#event:MESSAGE_DROPRPC#event:PINGRPC#event:readyRPC#event:STORERPC#event:TIMEOUTTCPTransport#event:CONTACT_SEENTCPTransport#event:FIND_NODETCPTransport#event:FIND_VALUETCPTransport#event:MESSAGE_DROPTCPTransport#event:PINGTCPTransport#event:readyTCPTransport#event:STORETCPTransport#event:TIMEOUTUDPTransport#event:CONTACT_SEENUDPTransport#event:FIND_NODEUDPTransport#event:FIND_VALUEUDPTransport#event:MESSAGE_DROPUDPTransport#event:PINGUDPTransport#event:readyUDPTransport#event:STOREUDPTransport#event:TIMEOUT Tutorials Custom ContactsCustom Storage AdaptersCustom Transport AdaptersProtocol SpecificationUsing Hooks Externals kad-fskad-localstoragekad-memstore Classes Classes AddressPortContact Bucket Contact HTTPTransport Item Logger Message FS LocalStorage MemStore Node Router RPC TCPTransport UDPTransport Events CONTACT_SEEN Triggered when a contact is seen Parameters: Name Type Description contact Contact The contact that was just encountered Inherited From: RPC#event:CONTACT_SEEN Source: lib/rpc.js, line 47 FIND_NODE Triggered when a FIND_NODE RPC is received Parameters: Name Type Description message Message The message received Inherited From: RPC#event:FIND_NODE Source: lib/rpc.js, line 60 FIND_VALUE Triggered when a FIND_VALUE RPC message is received Parameters: Name Type Description message Message The message received Inherited From: RPC#event:FIND_VALUE Source: lib/rpc.js, line 66 MESSAGE_DROP Triggered when an invalid RPC message is dropped Parameters: Name Type Description message Buffer The raw invalid message received Inherited From: RPC#event:MESSAGE_DROP Source: lib/rpc.js, line 84 PING Triggered when a PING RPC message is received Parameters: Name Type Description message Message The message received Inherited From: RPC#event:PING Source: lib/rpc.js, line 72 ready Triggered when the underlying transport is open Inherited From: RPC#event:ready Source: lib/rpc.js, line 42 STORE Triggered when a STORE RPC message is received Parameters: Name Type Description message Message The message received Inherited From: RPC#event:STORE Source: lib/rpc.js, line 78 TIMEOUT Triggered when a RPC message times out Parameters: Name Type Description contact Contact The contact that did not respond message Message The message sent that timed out Inherited From: RPC#event:TIMEOUT Source: lib/rpc.js, line 53 connect Aliases Node#event:join for backwards compatibility; use one or the other, but not both Deprecated: since version 1.4.0, use Node#event:join instead Source: lib/node.js, line 74 disconnect Aliases Node#event:leave for backwards compatibility; use one or the other, but not both Deprecated: since version 1.4.0, use Node#event:leave instead Source: lib/node.js, line 81 error Error event fires when a critical failure has occurred; if no handler is specified, then it will throw Type: Error Source: lib/node.js, line 88 join Join event is triggered when the routing table is no longer empty Source: lib/node.js, line 64 leave Leave event is triggered when the routing table becomes empty Source: lib/node.js, line 69 add Add event is triggered when a new Contact is added to the router Source: lib/router.js, line 52 drop Drop event is triggered when a Contact is dropped from the router Source: lib/router.js, line 57 shift Shift event is triggered when a Contact changes position in a Bucket Source: lib/router.js, line 62 CONTACT_SEEN Triggered when a contact is seen Parameters: Name Type Description contact Contact The contact that was just encountered Source: lib/rpc.js, line 47 FIND_NODE Triggered when a FIND_NODE RPC is received Parameters: Name Type Description message Message The message received Source: lib/rpc.js, line 60 FIND_VALUE Triggered when a FIND_VALUE RPC message is received Parameters: Name Type Description message Message The message received Source: lib/rpc.js, line 66 MESSAGE_DROP Triggered when an invalid RPC message is dropped Parameters: Name Type Description message Buffer The raw invalid message received Source: lib/rpc.js, line 84 PING Triggered when a PING RPC message is received Parameters: Name Type Description message Message The message received Source: lib/rpc.js, line 72 ready Triggered when the underlying transport is open Source: lib/rpc.js, line 42 STORE Triggered when a STORE RPC message is received Parameters: Name Type Description message Message The message received Source: lib/rpc.js, line 78 TIMEOUT Triggered when a RPC message times out Parameters: Name Type Description contact Contact The contact that did not respond message Message The message sent that timed out Source: lib/rpc.js, line 53 CONTACT_SEEN Triggered when a contact is seen Parameters: Name Type Description contact Contact The contact that was just encountered Inherited From: RPC#event:CONTACT_SEEN Source: lib/rpc.js, line 47 FIND_NODE Triggered when a FIND_NODE RPC is received Parameters: Name Type Description message Message The message received Inherited From: RPC#event:FIND_NODE Source: lib/rpc.js, line 60 FIND_VALUE Triggered when a FIND_VALUE RPC message is received Parameters: Name Type Description message Message The message received Inherited From: RPC#event:FIND_VALUE Source: lib/rpc.js, line 66 MESSAGE_DROP Triggered when an invalid RPC message is dropped Parameters: Name Type Description message Buffer The raw invalid message received Inherited From: RPC#event:MESSAGE_DROP Source: lib/rpc.js, line 84 PING Triggered when a PING RPC message is received Parameters: Name Type Description message Message The message received Inherited From: RPC#event:PING Source: lib/rpc.js, line 72 ready Triggered when the underlying transport is open Inherited From: RPC#event:ready Source: lib/rpc.js, line 42 STORE Triggered when a STORE RPC message is received Parameters: Name Type Description message Message The message received Inherited From: RPC#event:STORE Source: lib/rpc.js, line 78 TIMEOUT Triggered when a RPC message times out Parameters: Name Type Description contact Contact The contact that did not respond message Message The message sent that timed out Inherited From: RPC#event:TIMEOUT Source: lib/rpc.js, line 53 CONTACT_SEEN Triggered when a contact is seen Parameters: Name Type Description contact Contact The contact that was just encountered Inherited From: RPC#event:CONTACT_SEEN Source: lib/rpc.js, line 47 FIND_NODE Triggered when a FIND_NODE RPC is received Parameters: Name Type Description message Message The message received Inherited From: RPC#event:FIND_NODE Source: lib/rpc.js, line 60 FIND_VALUE Triggered when a FIND_VALUE RPC message is received Parameters: Name Type Description message Message The message received Inherited From: RPC#event:FIND_VALUE Source: lib/rpc.js, line 66 MESSAGE_DROP Triggered when an invalid RPC message is dropped Parameters: Name Type Description message Buffer The raw invalid message received Inherited From: RPC#event:MESSAGE_DROP Source: lib/rpc.js, line 84 PING Triggered when a PING RPC message is received Parameters: Name Type Description message Message The message received Inherited From: RPC#event:PING Source: lib/rpc.js, line 72 ready Triggered when the underlying transport is open Inherited From: RPC#event:ready Source: lib/rpc.js, line 42 STORE Triggered when a STORE RPC message is received Parameters: Name Type Description message Message The message received Inherited From: RPC#event:STORE Source: lib/rpc.js, line 78 TIMEOUT Triggered when a RPC message times out Parameters: Name Type Description contact Contact The contact that did not respond message Message The message sent that timed out Inherited From: RPC#event:TIMEOUT Source: lib/rpc.js, line 53 × Search results Close Documentation generated by JSDoc 3.4.3 using the DocStrap template. "},"externals.list.html":{"id":"externals.list.html","title":"Externals","body":" KadTools Modules kadkad/constantskad/contactskad/hookskad/storagekad/transportskad/utils Classes AddressPortContactBucketContactHTTPTransportItemLoggerMessagekad/storage.FSkad/storage.LocalStoragekad/storage.MemStoreNodeRouterRPCTCPTransportUDPTransport Events HTTPTransport#event:CONTACT_SEENHTTPTransport#event:FIND_NODEHTTPTransport#event:FIND_VALUEHTTPTransport#event:MESSAGE_DROPHTTPTransport#event:PINGHTTPTransport#event:readyHTTPTransport#event:STOREHTTPTransport#event:TIMEOUTNode#event:connectNode#event:disconnectNode#event:errorNode#event:joinNode#event:leaveRouter#event:addRouter#event:dropRouter#event:shiftRPC#event:CONTACT_SEENRPC#event:FIND_NODERPC#event:FIND_VALUERPC#event:MESSAGE_DROPRPC#event:PINGRPC#event:readyRPC#event:STORERPC#event:TIMEOUTTCPTransport#event:CONTACT_SEENTCPTransport#event:FIND_NODETCPTransport#event:FIND_VALUETCPTransport#event:MESSAGE_DROPTCPTransport#event:PINGTCPTransport#event:readyTCPTransport#event:STORETCPTransport#event:TIMEOUTUDPTransport#event:CONTACT_SEENUDPTransport#event:FIND_NODEUDPTransport#event:FIND_VALUEUDPTransport#event:MESSAGE_DROPUDPTransport#event:PINGUDPTransport#event:readyUDPTransport#event:STOREUDPTransport#event:TIMEOUT Tutorials Custom ContactsCustom Storage AdaptersCustom Transport AdaptersProtocol SpecificationUsing Hooks Externals kad-fskad-localstoragekad-memstore Externals Classes AddressPortContact Bucket Contact HTTPTransport Item Logger Message FS LocalStorage MemStore Node Router RPC TCPTransport UDPTransport Events CONTACT_SEEN Triggered when a contact is seen Parameters: Name Type Description contact Contact The contact that was just encountered Inherited From: RPC#event:CONTACT_SEEN Source: lib/rpc.js, line 47 FIND_NODE Triggered when a FIND_NODE RPC is received Parameters: Name Type Description message Message The message received Inherited From: RPC#event:FIND_NODE Source: lib/rpc.js, line 60 FIND_VALUE Triggered when a FIND_VALUE RPC message is received Parameters: Name Type Description message Message The message received Inherited From: RPC#event:FIND_VALUE Source: lib/rpc.js, line 66 MESSAGE_DROP Triggered when an invalid RPC message is dropped Parameters: Name Type Description message Buffer The raw invalid message received Inherited From: RPC#event:MESSAGE_DROP Source: lib/rpc.js, line 84 PING Triggered when a PING RPC message is received Parameters: Name Type Description message Message The message received Inherited From: RPC#event:PING Source: lib/rpc.js, line 72 ready Triggered when the underlying transport is open Inherited From: RPC#event:ready Source: lib/rpc.js, line 42 STORE Triggered when a STORE RPC message is received Parameters: Name Type Description message Message The message received Inherited From: RPC#event:STORE Source: lib/rpc.js, line 78 TIMEOUT Triggered when a RPC message times out Parameters: Name Type Description contact Contact The contact that did not respond message Message The message sent that timed out Inherited From: RPC#event:TIMEOUT Source: lib/rpc.js, line 53 connect Aliases Node#event:join for backwards compatibility; use one or the other, but not both Deprecated: since version 1.4.0, use Node#event:join instead Source: lib/node.js, line 74 disconnect Aliases Node#event:leave for backwards compatibility; use one or the other, but not both Deprecated: since version 1.4.0, use Node#event:leave instead Source: lib/node.js, line 81 error Error event fires when a critical failure has occurred; if no handler is specified, then it will throw Type: Error Source: lib/node.js, line 88 join Join event is triggered when the routing table is no longer empty Source: lib/node.js, line 64 leave Leave event is triggered when the routing table becomes empty Source: lib/node.js, line 69 add Add event is triggered when a new Contact is added to the router Source: lib/router.js, line 52 drop Drop event is triggered when a Contact is dropped from the router Source: lib/router.js, line 57 shift Shift event is triggered when a Contact changes position in a Bucket Source: lib/router.js, line 62 CONTACT_SEEN Triggered when a contact is seen Parameters: Name Type Description contact Contact The contact that was just encountered Source: lib/rpc.js, line 47 FIND_NODE Triggered when a FIND_NODE RPC is received Parameters: Name Type Description message Message The message received Source: lib/rpc.js, line 60 FIND_VALUE Triggered when a FIND_VALUE RPC message is received Parameters: Name Type Description message Message The message received Source: lib/rpc.js, line 66 MESSAGE_DROP Triggered when an invalid RPC message is dropped Parameters: Name Type Description message Buffer The raw invalid message received Source: lib/rpc.js, line 84 PING Triggered when a PING RPC message is received Parameters: Name Type Description message Message The message received Source: lib/rpc.js, line 72 ready Triggered when the underlying transport is open Source: lib/rpc.js, line 42 STORE Triggered when a STORE RPC message is received Parameters: Name Type Description message Message The message received Source: lib/rpc.js, line 78 TIMEOUT Triggered when a RPC message times out Parameters: Name Type Description contact Contact The contact that did not respond message Message The message sent that timed out Source: lib/rpc.js, line 53 CONTACT_SEEN Triggered when a contact is seen Parameters: Name Type Description contact Contact The contact that was just encountered Inherited From: RPC#event:CONTACT_SEEN Source: lib/rpc.js, line 47 FIND_NODE Triggered when a FIND_NODE RPC is received Parameters: Name Type Description message Message The message received Inherited From: RPC#event:FIND_NODE Source: lib/rpc.js, line 60 FIND_VALUE Triggered when a FIND_VALUE RPC message is received Parameters: Name Type Description message Message The message received Inherited From: RPC#event:FIND_VALUE Source: lib/rpc.js, line 66 MESSAGE_DROP Triggered when an invalid RPC message is dropped Parameters: Name Type Description message Buffer The raw invalid message received Inherited From: RPC#event:MESSAGE_DROP Source: lib/rpc.js, line 84 PING Triggered when a PING RPC message is received Parameters: Name Type Description message Message The message received Inherited From: RPC#event:PING Source: lib/rpc.js, line 72 ready Triggered when the underlying transport is open Inherited From: RPC#event:ready Source: lib/rpc.js, line 42 STORE Triggered when a STORE RPC message is received Parameters: Name Type Description message Message The message received Inherited From: RPC#event:STORE Source: lib/rpc.js, line 78 TIMEOUT Triggered when a RPC message times out Parameters: Name Type Description contact Contact The contact that did not respond message Message The message sent that timed out Inherited From: RPC#event:TIMEOUT Source: lib/rpc.js, line 53 CONTACT_SEEN Triggered when a contact is seen Parameters: Name Type Description contact Contact The contact that was just encountered Inherited From: RPC#event:CONTACT_SEEN Source: lib/rpc.js, line 47 FIND_NODE Triggered when a FIND_NODE RPC is received Parameters: Name Type Description message Message The message received Inherited From: RPC#event:FIND_NODE Source: lib/rpc.js, line 60 FIND_VALUE Triggered when a FIND_VALUE RPC message is received Parameters: Name Type Description message Message The message received Inherited From: RPC#event:FIND_VALUE Source: lib/rpc.js, line 66 MESSAGE_DROP Triggered when an invalid RPC message is dropped Parameters: Name Type Description message Buffer The raw invalid message received Inherited From: RPC#event:MESSAGE_DROP Source: lib/rpc.js, line 84 PING Triggered when a PING RPC message is received Parameters: Name Type Description message Message The message received Inherited From: RPC#event:PING Source: lib/rpc.js, line 72 ready Triggered when the underlying transport is open Inherited From: RPC#event:ready Source: lib/rpc.js, line 42 STORE Triggered when a STORE RPC message is received Parameters: Name Type Description message Message The message received Inherited From: RPC#event:STORE Source: lib/rpc.js, line 78 TIMEOUT Triggered when a RPC message times out Parameters: Name Type Description contact Contact The contact that did not respond message Message The message sent that timed out Inherited From: RPC#event:TIMEOUT Source: lib/rpc.js, line 53 × Search results Close Documentation generated by JSDoc 3.4.3 using the DocStrap template. "},"tutorials.list.html":{"id":"tutorials.list.html","title":"Tutorials","body":" KadTools Modules kadkad/constantskad/contactskad/hookskad/storagekad/transportskad/utils Classes AddressPortContactBucketContactHTTPTransportItemLoggerMessagekad/storage.FSkad/storage.LocalStoragekad/storage.MemStoreNodeRouterRPCTCPTransportUDPTransport Events HTTPTransport#event:CONTACT_SEENHTTPTransport#event:FIND_NODEHTTPTransport#event:FIND_VALUEHTTPTransport#event:MESSAGE_DROPHTTPTransport#event:PINGHTTPTransport#event:readyHTTPTransport#event:STOREHTTPTransport#event:TIMEOUTNode#event:connectNode#event:disconnectNode#event:errorNode#event:joinNode#event:leaveRouter#event:addRouter#event:dropRouter#event:shiftRPC#event:CONTACT_SEENRPC#event:FIND_NODERPC#event:FIND_VALUERPC#event:MESSAGE_DROPRPC#event:PINGRPC#event:readyRPC#event:STORERPC#event:TIMEOUTTCPTransport#event:CONTACT_SEENTCPTransport#event:FIND_NODETCPTransport#event:FIND_VALUETCPTransport#event:MESSAGE_DROPTCPTransport#event:PINGTCPTransport#event:readyTCPTransport#event:STORETCPTransport#event:TIMEOUTUDPTransport#event:CONTACT_SEENUDPTransport#event:FIND_NODEUDPTransport#event:FIND_VALUEUDPTransport#event:MESSAGE_DROPUDPTransport#event:PINGUDPTransport#event:readyUDPTransport#event:STOREUDPTransport#event:TIMEOUT Tutorials Custom ContactsCustom Storage AdaptersCustom Transport AdaptersProtocol SpecificationUsing Hooks Externals kad-fskad-localstoragekad-memstore Tutorials Classes AddressPortContact Bucket Contact HTTPTransport Item Logger Message FS LocalStorage MemStore Node Router RPC TCPTransport UDPTransport Events CONTACT_SEEN Triggered when a contact is seen Parameters: Name Type Description contact Contact The contact that was just encountered Inherited From: RPC#event:CONTACT_SEEN Source: lib/rpc.js, line 47 FIND_NODE Triggered when a FIND_NODE RPC is received Parameters: Name Type Description message Message The message received Inherited From: RPC#event:FIND_NODE Source: lib/rpc.js, line 60 FIND_VALUE Triggered when a FIND_VALUE RPC message is received Parameters: Name Type Description message Message The message received Inherited From: RPC#event:FIND_VALUE Source: lib/rpc.js, line 66 MESSAGE_DROP Triggered when an invalid RPC message is dropped Parameters: Name Type Description message Buffer The raw invalid message received Inherited From: RPC#event:MESSAGE_DROP Source: lib/rpc.js, line 84 PING Triggered when a PING RPC message is received Parameters: Name Type Description message Message The message received Inherited From: RPC#event:PING Source: lib/rpc.js, line 72 ready Triggered when the underlying transport is open Inherited From: RPC#event:ready Source: lib/rpc.js, line 42 STORE Triggered when a STORE RPC message is received Parameters: Name Type Description message Message The message received Inherited From: RPC#event:STORE Source: lib/rpc.js, line 78 TIMEOUT Triggered when a RPC message times out Parameters: Name Type Description contact Contact The contact that did not respond message Message The message sent that timed out Inherited From: RPC#event:TIMEOUT Source: lib/rpc.js, line 53 connect Aliases Node#event:join for backwards compatibility; use one or the other, but not both Deprecated: since version 1.4.0, use Node#event:join instead Source: lib/node.js, line 74 disconnect Aliases Node#event:leave for backwards compatibility; use one or the other, but not both Deprecated: since version 1.4.0, use Node#event:leave instead Source: lib/node.js, line 81 error Error event fires when a critical failure has occurred; if no handler is specified, then it will throw Type: Error Source: lib/node.js, line 88 join Join event is triggered when the routing table is no longer empty Source: lib/node.js, line 64 leave Leave event is triggered when the routing table becomes empty Source: lib/node.js, line 69 add Add event is triggered when a new Contact is added to the router Source: lib/router.js, line 52 drop Drop event is triggered when a Contact is dropped from the router Source: lib/router.js, line 57 shift Shift event is triggered when a Contact changes position in a Bucket Source: lib/router.js, line 62 CONTACT_SEEN Triggered when a contact is seen Parameters: Name Type Description contact Contact The contact that was just encountered Source: lib/rpc.js, line 47 FIND_NODE Triggered when a FIND_NODE RPC is received Parameters: Name Type Description message Message The message received Source: lib/rpc.js, line 60 FIND_VALUE Triggered when a FIND_VALUE RPC message is received Parameters: Name Type Description message Message The message received Source: lib/rpc.js, line 66 MESSAGE_DROP Triggered when an invalid RPC message is dropped Parameters: Name Type Description message Buffer The raw invalid message received Source: lib/rpc.js, line 84 PING Triggered when a PING RPC message is received Parameters: Name Type Description message Message The message received Source: lib/rpc.js, line 72 ready Triggered when the underlying transport is open Source: lib/rpc.js, line 42 STORE Triggered when a STORE RPC message is received Parameters: Name Type Description message Message The message received Source: lib/rpc.js, line 78 TIMEOUT Triggered when a RPC message times out Parameters: Name Type Description contact Contact The contact that did not respond message Message The message sent that timed out Source: lib/rpc.js, line 53 CONTACT_SEEN Triggered when a contact is seen Parameters: Name Type Description contact Contact The contact that was just encountered Inherited From: RPC#event:CONTACT_SEEN Source: lib/rpc.js, line 47 FIND_NODE Triggered when a FIND_NODE RPC is received Parameters: Name Type Description message Message The message received Inherited From: RPC#event:FIND_NODE Source: lib/rpc.js, line 60 FIND_VALUE Triggered when a FIND_VALUE RPC message is received Parameters: Name Type Description message Message The message received Inherited From: RPC#event:FIND_VALUE Source: lib/rpc.js, line 66 MESSAGE_DROP Triggered when an invalid RPC message is dropped Parameters: Name Type Description message Buffer The raw invalid message received Inherited From: RPC#event:MESSAGE_DROP Source: lib/rpc.js, line 84 PING Triggered when a PING RPC message is received Parameters: Name Type Description message Message The message received Inherited From: RPC#event:PING Source: lib/rpc.js, line 72 ready Triggered when the underlying transport is open Inherited From: RPC#event:ready Source: lib/rpc.js, line 42 STORE Triggered when a STORE RPC message is received Parameters: Name Type Description message Message The message received Inherited From: RPC#event:STORE Source: lib/rpc.js, line 78 TIMEOUT Triggered when a RPC message times out Parameters: Name Type Description contact Contact The contact that did not respond message Message The message sent that timed out Inherited From: RPC#event:TIMEOUT Source: lib/rpc.js, line 53 CONTACT_SEEN Triggered when a contact is seen Parameters: Name Type Description contact Contact The contact that was just encountered Inherited From: RPC#event:CONTACT_SEEN Source: lib/rpc.js, line 47 FIND_NODE Triggered when a FIND_NODE RPC is received Parameters: Name Type Description message Message The message received Inherited From: RPC#event:FIND_NODE Source: lib/rpc.js, line 60 FIND_VALUE Triggered when a FIND_VALUE RPC message is received Parameters: Name Type Description message Message The message received Inherited From: RPC#event:FIND_VALUE Source: lib/rpc.js, line 66 MESSAGE_DROP Triggered when an invalid RPC message is dropped Parameters: Name Type Description message Buffer The raw invalid message received Inherited From: RPC#event:MESSAGE_DROP Source: lib/rpc.js, line 84 PING Triggered when a PING RPC message is received Parameters: Name Type Description message Message The message received Inherited From: RPC#event:PING Source: lib/rpc.js, line 72 ready Triggered when the underlying transport is open Inherited From: RPC#event:ready Source: lib/rpc.js, line 42 STORE Triggered when a STORE RPC message is received Parameters: Name Type Description message Message The message received Inherited From: RPC#event:STORE Source: lib/rpc.js, line 78 TIMEOUT Triggered when a RPC message times out Parameters: Name Type Description contact Contact The contact that did not respond message Message The message sent that timed out Inherited From: RPC#event:TIMEOUT Source: lib/rpc.js, line 53 × Search results Close Documentation generated by JSDoc 3.4.3 using the DocStrap template. "},"index.html":{"id":"index.html","title":"Index","body":" KadTools Modules kadkad/constantskad/contactskad/hookskad/storagekad/transportskad/utils Classes AddressPortContactBucketContactHTTPTransportItemLoggerMessagekad/storage.FSkad/storage.LocalStoragekad/storage.MemStoreNodeRouterRPCTCPTransportUDPTransport Events HTTPTransport#event:CONTACT_SEENHTTPTransport#event:FIND_NODEHTTPTransport#event:FIND_VALUEHTTPTransport#event:MESSAGE_DROPHTTPTransport#event:PINGHTTPTransport#event:readyHTTPTransport#event:STOREHTTPTransport#event:TIMEOUTNode#event:connectNode#event:disconnectNode#event:errorNode#event:joinNode#event:leaveRouter#event:addRouter#event:dropRouter#event:shiftRPC#event:CONTACT_SEENRPC#event:FIND_NODERPC#event:FIND_VALUERPC#event:MESSAGE_DROPRPC#event:PINGRPC#event:readyRPC#event:STORERPC#event:TIMEOUTTCPTransport#event:CONTACT_SEENTCPTransport#event:FIND_NODETCPTransport#event:FIND_VALUETCPTransport#event:MESSAGE_DROPTCPTransport#event:PINGTCPTransport#event:readyTCPTransport#event:STORETCPTransport#event:TIMEOUTUDPTransport#event:CONTACT_SEENUDPTransport#event:FIND_NODEUDPTransport#event:FIND_VALUEUDPTransport#event:MESSAGE_DROPUDPTransport#event:PINGUDPTransport#event:readyUDPTransport#event:STOREUDPTransport#event:TIMEOUT Tutorials Custom ContactsCustom Storage AdaptersCustom Transport AdaptersProtocol SpecificationUsing Hooks Externals kad-fskad-localstoragekad-memstore Extensible implementation of the Kademlia distributed hash table for Node.js and the browser. Quick StartFor complete documentation on using and extending Kad, read the documentation. npm install kadCreate your node, plug in your storage adapter, join the network, and party! var kad = require('kad'); var seed = { address: '127.0.0.1', port: 1338 }; var dht = new kad.Node({ transport: kad.transports.UDP(kad.contacts.AddressPortContact({ address: '127.0.0.1', port: 1337 })), storage: kad.storage.FS('path/to/datadir') }); dht.connect(seed, function(err) { // dht.get(key, callback); // dht.put(key, value, callback); });You can build Kad for the browser by running: npm run build This will output to dist/kad.browser.js and will bind to window when loaded in your web application. You can run a network simulation locally using the included simulator. This will create n nodes (as you define) and connect them to each other, sending STORE messages on an interval and printing information to the console. # use the default of 6 nodes npm run simulation # specify as many nodes as you like npm run simulation 128TransportsKad ships with support for UDP, TCP, and HTTP transports. To explicitly define the transport to use, set the transport option to the appropriate value. See the documentation on RPC and Contact for more information. var dht = new kademlia.Node({ // ... transport: kademlia.transports.TCP(contact, options) });If you would like to author your own transport adapter, see kad-transport-boilerplate. Community Transport Adapters WebRTC PersistenceKad does not make assumptions about how your nodes will store their data, instead relying on you to implement a storage adapter of your choice. This is as simple as providing get(key, callback), put(key, value, callback), del(key, callback), and createReadStream() methods. This works well with levelup, but you could conceivably implement any storage layer you like provided you expose the interface described above. Some adapters have already been contributed by the community, listed below. Community Storage Adapters Local Storage MongoDB File System ExtensionsSybil/Spartacus MitigationYou can use kad-spartacus to mitigate 2 types of attacks to which a Kademlia DHT may be vulnerable: the Sybil attack and it's variant, Spartacus. Read More → NAT TraversalYou can use kad-traverse to ensure your nodes are able to communicate when behind a NAT or firewall. The extension will use different strategies based on the network configuration. Read More → Performance MonitoringYou can use kad-telemetry to track the performance of your peers and extend the default routing algorithm to prioritize the selection of nodes with a higher score. Read More → Publish &amp; SubscribeYou can use kad-quasar to extend kad with support for probabilistic, topic-based publish/subscribe capabilities. Read More → LicenseThis program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with this program. If not, see http://www.gnu.org/licenses/. × Search results Close Documentation generated by JSDoc 3.4.3 using the DocStrap template. "},"AddressPortContact.html":{"id":"AddressPortContact.html","title":"Class: AddressPortContact","body":" KadTools Modules kadkad/constantskad/contactskad/hookskad/storagekad/transportskad/utils Classes AddressPortContactBucketContactHTTPTransportItemLoggerMessagekad/storage.FSkad/storage.LocalStoragekad/storage.MemStoreNodeRouterRPCTCPTransportUDPTransport Events HTTPTransport#event:CONTACT_SEENHTTPTransport#event:FIND_NODEHTTPTransport#event:FIND_VALUEHTTPTransport#event:MESSAGE_DROPHTTPTransport#event:PINGHTTPTransport#event:readyHTTPTransport#event:STOREHTTPTransport#event:TIMEOUTNode#event:connectNode#event:disconnectNode#event:errorNode#event:joinNode#event:leaveRouter#event:addRouter#event:dropRouter#event:shiftRPC#event:CONTACT_SEENRPC#event:FIND_NODERPC#event:FIND_VALUERPC#event:MESSAGE_DROPRPC#event:PINGRPC#event:readyRPC#event:STORERPC#event:TIMEOUTTCPTransport#event:CONTACT_SEENTCPTransport#event:FIND_NODETCPTransport#event:FIND_VALUETCPTransport#event:MESSAGE_DROPTCPTransport#event:PINGTCPTransport#event:readyTCPTransport#event:STORETCPTransport#event:TIMEOUTUDPTransport#event:CONTACT_SEENUDPTransport#event:FIND_NODEUDPTransport#event:FIND_VALUEUDPTransport#event:MESSAGE_DROPUDPTransport#event:PINGUDPTransport#event:readyUDPTransport#event:STOREUDPTransport#event:TIMEOUT Tutorials Custom ContactsCustom Storage AdaptersCustom Transport AdaptersProtocol SpecificationUsing Hooks Externals kad-fskad-localstoragekad-memstore Class: AddressPortContact AddressPortContact new AddressPortContact(options) Represent a contact (or peer) Parameters: Name Type Description options Object Properties Name Type Description address String IP or hostname port Number Listening port Source: lib/contacts/address-port-contact.js, line 16 Extends Contact Methods seen() Updates the lastSeen property to right now Inherited From: Contact#seen Source: lib/contact.js, line 39 toString() Generate a user-friendly string for the contact Source: lib/contacts/address-port-contact.js, line 52 valid() Ensures that the address and port are valid Overrides: Contact#valid Source: lib/contacts/address-port-contact.js, line 45 Returns: Type Boolean × Search results Close Documentation generated by JSDoc 3.4.3 using the DocStrap template. "},"Bucket.html":{"id":"Bucket.html","title":"Class: Bucket","body":" KadTools Modules kadkad/constantskad/contactskad/hookskad/storagekad/transportskad/utils Classes AddressPortContactBucketContactHTTPTransportItemLoggerMessagekad/storage.FSkad/storage.LocalStoragekad/storage.MemStoreNodeRouterRPCTCPTransportUDPTransport Events HTTPTransport#event:CONTACT_SEENHTTPTransport#event:FIND_NODEHTTPTransport#event:FIND_VALUEHTTPTransport#event:MESSAGE_DROPHTTPTransport#event:PINGHTTPTransport#event:readyHTTPTransport#event:STOREHTTPTransport#event:TIMEOUTNode#event:connectNode#event:disconnectNode#event:errorNode#event:joinNode#event:leaveRouter#event:addRouter#event:dropRouter#event:shiftRPC#event:CONTACT_SEENRPC#event:FIND_NODERPC#event:FIND_VALUERPC#event:MESSAGE_DROPRPC#event:PINGRPC#event:readyRPC#event:STORERPC#event:TIMEOUTTCPTransport#event:CONTACT_SEENTCPTransport#event:FIND_NODETCPTransport#event:FIND_VALUETCPTransport#event:MESSAGE_DROPTCPTransport#event:PINGTCPTransport#event:readyTCPTransport#event:STORETCPTransport#event:TIMEOUTUDPTransport#event:CONTACT_SEENUDPTransport#event:FIND_NODEUDPTransport#event:FIND_VALUEUDPTransport#event:MESSAGE_DROPUDPTransport#event:PINGUDPTransport#event:readyUDPTransport#event:STOREUDPTransport#event:TIMEOUT Tutorials Custom ContactsCustom Storage AdaptersCustom Transport AdaptersProtocol SpecificationUsing Hooks Externals kad-fskad-localstoragekad-memstore Class: Bucket Bucket new Bucket() A bucket is a &quot;column&quot; of the routing table. It is an array-like object that holds Contacts. Source: lib/bucket.js, line 13 Methods addContact(contact) Adds the contact to the bucket Parameters: Name Type Description contact Contact Contact instance to add to bucket Source: lib/bucket.js, line 53 Returns: added - Indicates whether or not the contact was added Type Boolean getContact(index) Return the contact at the given index Parameters: Name Type Description index Number Index of contact in bucket Source: lib/bucket.js, line 42 Returns: Type Contact | null getContactList() Return the list of contacts in this bucket Source: lib/bucket.js, line 33 Returns: Type Array getSize() Return the number of contacts in this bucket Source: lib/bucket.js, line 25 Returns: Type Number hasContact(nodeID) Returns boolean indicating that the nodeID is contained in the bucket Parameters: Name Type Description nodeID String 160 bit node ID Source: lib/bucket.js, line 92 Returns: Type Boolean indexOf(contact) Returns the index of the given contact Parameters: Name Type Description contact Contact Contact instance for index check Source: lib/bucket.js, line 107 Returns: Type Number removeContact(contact) Removes the contact from the bucket Parameters: Name Type Description contact Contact Contact instance to remove from bucket Source: lib/bucket.js, line 76 Returns: removed - Indicates whether or not the contact was removed Type Boolean × Search results Close Documentation generated by JSDoc 3.4.3 using the DocStrap template. "},"Contact.html":{"id":"Contact.html","title":"Class: Contact","body":" KadTools Modules kadkad/constantskad/contactskad/hookskad/storagekad/transportskad/utils Classes AddressPortContactBucketContactHTTPTransportItemLoggerMessagekad/storage.FSkad/storage.LocalStoragekad/storage.MemStoreNodeRouterRPCTCPTransportUDPTransport Events HTTPTransport#event:CONTACT_SEENHTTPTransport#event:FIND_NODEHTTPTransport#event:FIND_VALUEHTTPTransport#event:MESSAGE_DROPHTTPTransport#event:PINGHTTPTransport#event:readyHTTPTransport#event:STOREHTTPTransport#event:TIMEOUTNode#event:connectNode#event:disconnectNode#event:errorNode#event:joinNode#event:leaveRouter#event:addRouter#event:dropRouter#event:shiftRPC#event:CONTACT_SEENRPC#event:FIND_NODERPC#event:FIND_VALUERPC#event:MESSAGE_DROPRPC#event:PINGRPC#event:readyRPC#event:STORERPC#event:TIMEOUTTCPTransport#event:CONTACT_SEENTCPTransport#event:FIND_NODETCPTransport#event:FIND_VALUETCPTransport#event:MESSAGE_DROPTCPTransport#event:PINGTCPTransport#event:readyTCPTransport#event:STORETCPTransport#event:TIMEOUTUDPTransport#event:CONTACT_SEENUDPTransport#event:FIND_NODEUDPTransport#event:FIND_VALUEUDPTransport#event:MESSAGE_DROPUDPTransport#event:PINGUDPTransport#event:readyUDPTransport#event:STOREUDPTransport#event:TIMEOUT Tutorials Custom ContactsCustom Storage AdaptersCustom Transport AdaptersProtocol SpecificationUsing Hooks Externals kad-fskad-localstoragekad-memstore Class: Contact Contact new Contact(options) The base class from which custom contacts inherit; used by the included AddressPortContact. Nodes provide each other with contact information which indicates how others should communicate with them. Parameters: Name Type Description options Object Properties Name Type Description nodeID String Optional known 160 bit node ID Source: lib/contact.js, line 14 Methods seen() Updates the lastSeen property to right now Source: lib/contact.js, line 39 &lt;abstract&gt; valid() Validator function for determining if contact is okay Source: lib/contact.js, line 48 Returns: Type Boolean × Search results Close Documentation generated by JSDoc 3.4.3 using the DocStrap template. "},"external-kad-fs.html":{"id":"external-kad-fs.html","title":"External: kad-fs","body":" KadTools Modules kadkad/constantskad/contactskad/hookskad/storagekad/transportskad/utils Classes AddressPortContactBucketContactHTTPTransportItemLoggerMessagekad/storage.FSkad/storage.LocalStoragekad/storage.MemStoreNodeRouterRPCTCPTransportUDPTransport Events HTTPTransport#event:CONTACT_SEENHTTPTransport#event:FIND_NODEHTTPTransport#event:FIND_VALUEHTTPTransport#event:MESSAGE_DROPHTTPTransport#event:PINGHTTPTransport#event:readyHTTPTransport#event:STOREHTTPTransport#event:TIMEOUTNode#event:connectNode#event:disconnectNode#event:errorNode#event:joinNode#event:leaveRouter#event:addRouter#event:dropRouter#event:shiftRPC#event:CONTACT_SEENRPC#event:FIND_NODERPC#event:FIND_VALUERPC#event:MESSAGE_DROPRPC#event:PINGRPC#event:readyRPC#event:STORERPC#event:TIMEOUTTCPTransport#event:CONTACT_SEENTCPTransport#event:FIND_NODETCPTransport#event:FIND_VALUETCPTransport#event:MESSAGE_DROPTCPTransport#event:PINGTCPTransport#event:readyTCPTransport#event:STORETCPTransport#event:TIMEOUTUDPTransport#event:CONTACT_SEENUDPTransport#event:FIND_NODEUDPTransport#event:FIND_VALUEUDPTransport#event:MESSAGE_DROPUDPTransport#event:PINGUDPTransport#event:readyUDPTransport#event:STOREUDPTransport#event:TIMEOUT Tutorials Custom ContactsCustom Storage AdaptersCustom Transport AdaptersProtocol SpecificationUsing Hooks Externals kad-fskad-localstoragekad-memstore External: kad-fs kad/storage~ kad-fs Source: lib/storage.js, line 9 See: https://github.com/kadtools/kad-fs × Search results Close Documentation generated by JSDoc 3.4.3 using the DocStrap template. "},"external-kad-localstorage.html":{"id":"external-kad-localstorage.html","title":"External: kad-localstorage","body":" KadTools Modules kadkad/constantskad/contactskad/hookskad/storagekad/transportskad/utils Classes AddressPortContactBucketContactHTTPTransportItemLoggerMessagekad/storage.FSkad/storage.LocalStoragekad/storage.MemStoreNodeRouterRPCTCPTransportUDPTransport Events HTTPTransport#event:CONTACT_SEENHTTPTransport#event:FIND_NODEHTTPTransport#event:FIND_VALUEHTTPTransport#event:MESSAGE_DROPHTTPTransport#event:PINGHTTPTransport#event:readyHTTPTransport#event:STOREHTTPTransport#event:TIMEOUTNode#event:connectNode#event:disconnectNode#event:errorNode#event:joinNode#event:leaveRouter#event:addRouter#event:dropRouter#event:shiftRPC#event:CONTACT_SEENRPC#event:FIND_NODERPC#event:FIND_VALUERPC#event:MESSAGE_DROPRPC#event:PINGRPC#event:readyRPC#event:STORERPC#event:TIMEOUTTCPTransport#event:CONTACT_SEENTCPTransport#event:FIND_NODETCPTransport#event:FIND_VALUETCPTransport#event:MESSAGE_DROPTCPTransport#event:PINGTCPTransport#event:readyTCPTransport#event:STORETCPTransport#event:TIMEOUTUDPTransport#event:CONTACT_SEENUDPTransport#event:FIND_NODEUDPTransport#event:FIND_VALUEUDPTransport#event:MESSAGE_DROPUDPTransport#event:PINGUDPTransport#event:readyUDPTransport#event:STOREUDPTransport#event:TIMEOUT Tutorials Custom ContactsCustom Storage AdaptersCustom Transport AdaptersProtocol SpecificationUsing Hooks Externals kad-fskad-localstoragekad-memstore External: kad-localstorage kad/storage~ kad-localstorage Source: lib/storage.js, line 20 See: https://github.com/kadtools/kad-localstorage × Search results Close Documentation generated by JSDoc 3.4.3 using the DocStrap template. "},"external-kad-memstore.html":{"id":"external-kad-memstore.html","title":"External: kad-memstore","body":" KadTools Modules kadkad/constantskad/contactskad/hookskad/storagekad/transportskad/utils Classes AddressPortContactBucketContactHTTPTransportItemLoggerMessagekad/storage.FSkad/storage.LocalStoragekad/storage.MemStoreNodeRouterRPCTCPTransportUDPTransport Events HTTPTransport#event:CONTACT_SEENHTTPTransport#event:FIND_NODEHTTPTransport#event:FIND_VALUEHTTPTransport#event:MESSAGE_DROPHTTPTransport#event:PINGHTTPTransport#event:readyHTTPTransport#event:STOREHTTPTransport#event:TIMEOUTNode#event:connectNode#event:disconnectNode#event:errorNode#event:joinNode#event:leaveRouter#event:addRouter#event:dropRouter#event:shiftRPC#event:CONTACT_SEENRPC#event:FIND_NODERPC#event:FIND_VALUERPC#event:MESSAGE_DROPRPC#event:PINGRPC#event:readyRPC#event:STORERPC#event:TIMEOUTTCPTransport#event:CONTACT_SEENTCPTransport#event:FIND_NODETCPTransport#event:FIND_VALUETCPTransport#event:MESSAGE_DROPTCPTransport#event:PINGTCPTransport#event:readyTCPTransport#event:STORETCPTransport#event:TIMEOUTUDPTransport#event:CONTACT_SEENUDPTransport#event:FIND_NODEUDPTransport#event:FIND_VALUEUDPTransport#event:MESSAGE_DROPUDPTransport#event:PINGUDPTransport#event:readyUDPTransport#event:STOREUDPTransport#event:TIMEOUT Tutorials Custom ContactsCustom Storage AdaptersCustom Transport AdaptersProtocol SpecificationUsing Hooks Externals kad-fskad-localstoragekad-memstore External: kad-memstore kad/storage~ kad-memstore Source: lib/storage.js, line 31 See: https://github.com/kadtools/kad-memstore × Search results Close Documentation generated by JSDoc 3.4.3 using the DocStrap template. "},"HTTPTransport.html":{"id":"HTTPTransport.html","title":"Class: HTTPTransport","body":" KadTools Modules kadkad/constantskad/contactskad/hookskad/storagekad/transportskad/utils Classes AddressPortContactBucketContactHTTPTransportItemLoggerMessagekad/storage.FSkad/storage.LocalStoragekad/storage.MemStoreNodeRouterRPCTCPTransportUDPTransport Events HTTPTransport#event:CONTACT_SEENHTTPTransport#event:FIND_NODEHTTPTransport#event:FIND_VALUEHTTPTransport#event:MESSAGE_DROPHTTPTransport#event:PINGHTTPTransport#event:readyHTTPTransport#event:STOREHTTPTransport#event:TIMEOUTNode#event:connectNode#event:disconnectNode#event:errorNode#event:joinNode#event:leaveRouter#event:addRouter#event:dropRouter#event:shiftRPC#event:CONTACT_SEENRPC#event:FIND_NODERPC#event:FIND_VALUERPC#event:MESSAGE_DROPRPC#event:PINGRPC#event:readyRPC#event:STORERPC#event:TIMEOUTTCPTransport#event:CONTACT_SEENTCPTransport#event:FIND_NODETCPTransport#event:FIND_VALUETCPTransport#event:MESSAGE_DROPTCPTransport#event:PINGTCPTransport#event:readyTCPTransport#event:STORETCPTransport#event:TIMEOUTUDPTransport#event:CONTACT_SEENUDPTransport#event:FIND_NODEUDPTransport#event:FIND_VALUEUDPTransport#event:MESSAGE_DROPUDPTransport#event:PINGUDPTransport#event:readyUDPTransport#event:STOREUDPTransport#event:TIMEOUT Tutorials Custom ContactsCustom Storage AdaptersCustom Transport AdaptersProtocol SpecificationUsing Hooks Externals kad-fskad-localstoragekad-memstore Class: HTTPTransport HTTPTransport new HTTPTransport(contact, options) Transport adapter that sends and receives messages over HTTP Parameters: Name Type Description contact AddressPortContact Your node's Contact instance options Object Properties Name Type Description cors Boolean Allow cross origin resource sharing ssl Object Options to pass to https.createServer() Source: lib/transports/http.js, line 24 Extends RPC Methods after(event, handler) Registers an &quot;after&quot; hook Parameters: Name Type Description event String Name of the event to catch handler function Event handler to register Inherited From: RPC#after Source: lib/rpc.js, line 258 before(event, handler) Registers a &quot;before&quot; hook Parameters: Name Type Description event String Name of the event to catch handler function Event handler to register Inherited From: RPC#before Source: lib/rpc.js, line 249 close(callback) Closes the underlying transport Parameters: Name Type Description callback RPC~closeCallback Called when the transport is closed Inherited From: RPC#close Source: lib/rpc.js, line 128 open(callback) Opens the underlying transport Parameters: Name Type Description callback RPC~openCallback Called when the transport is opened Inherited From: RPC#open Source: lib/rpc.js, line 97 Fires: RPC#event:ready receive(buffer) Handle incoming messages Parameters: Name Type Description buffer Buffer Raw binary data to be processed by the RPC handler Inherited From: RPC#receive Source: lib/rpc.js, line 203 send(contact, message, callback) Send a RPC to the given contact Parameters: Name Type Description contact Contact Delivery target for message message Message Message to send to target callback RPC~sendCallback Response handler function Inherited From: RPC#send Source: lib/rpc.js, line 155 Events CONTACT_SEEN Triggered when a contact is seen Parameters: Name Type Description contact Contact The contact that was just encountered Inherited From: RPC#event:CONTACT_SEEN Source: lib/rpc.js, line 47 FIND_NODE Triggered when a FIND_NODE RPC is received Parameters: Name Type Description message Message The message received Inherited From: RPC#event:FIND_NODE Source: lib/rpc.js, line 60 FIND_VALUE Triggered when a FIND_VALUE RPC message is received Parameters: Name Type Description message Message The message received Inherited From: RPC#event:FIND_VALUE Source: lib/rpc.js, line 66 MESSAGE_DROP Triggered when an invalid RPC message is dropped Parameters: Name Type Description message Buffer The raw invalid message received Inherited From: RPC#event:MESSAGE_DROP Source: lib/rpc.js, line 84 PING Triggered when a PING RPC message is received Parameters: Name Type Description message Message The message received Inherited From: RPC#event:PING Source: lib/rpc.js, line 72 ready Triggered when the underlying transport is open Inherited From: RPC#event:ready Source: lib/rpc.js, line 42 STORE Triggered when a STORE RPC message is received Parameters: Name Type Description message Message The message received Inherited From: RPC#event:STORE Source: lib/rpc.js, line 78 TIMEOUT Triggered when a RPC message times out Parameters: Name Type Description contact Contact The contact that did not respond message Message The message sent that timed out Inherited From: RPC#event:TIMEOUT Source: lib/rpc.js, line 53 × Search results Close Documentation generated by JSDoc 3.4.3 using the DocStrap template. "},"Item.html":{"id":"Item.html","title":"Class: Item","body":" KadTools Modules kadkad/constantskad/contactskad/hookskad/storagekad/transportskad/utils Classes AddressPortContactBucketContactHTTPTransportItemLoggerMessagekad/storage.FSkad/storage.LocalStoragekad/storage.MemStoreNodeRouterRPCTCPTransportUDPTransport Events HTTPTransport#event:CONTACT_SEENHTTPTransport#event:FIND_NODEHTTPTransport#event:FIND_VALUEHTTPTransport#event:MESSAGE_DROPHTTPTransport#event:PINGHTTPTransport#event:readyHTTPTransport#event:STOREHTTPTransport#event:TIMEOUTNode#event:connectNode#event:disconnectNode#event:errorNode#event:joinNode#event:leaveRouter#event:addRouter#event:dropRouter#event:shiftRPC#event:CONTACT_SEENRPC#event:FIND_NODERPC#event:FIND_VALUERPC#event:MESSAGE_DROPRPC#event:PINGRPC#event:readyRPC#event:STORERPC#event:TIMEOUTTCPTransport#event:CONTACT_SEENTCPTransport#event:FIND_NODETCPTransport#event:FIND_VALUETCPTransport#event:MESSAGE_DROPTCPTransport#event:PINGTCPTransport#event:readyTCPTransport#event:STORETCPTransport#event:TIMEOUTUDPTransport#event:CONTACT_SEENUDPTransport#event:FIND_NODEUDPTransport#event:FIND_VALUEUDPTransport#event:MESSAGE_DROPUDPTransport#event:PINGUDPTransport#event:readyUDPTransport#event:STOREUDPTransport#event:TIMEOUT Tutorials Custom ContactsCustom Storage AdaptersCustom Transport AdaptersProtocol SpecificationUsing Hooks Externals kad-fskad-localstoragekad-memstore Class: Item Item new Item(key, value, publisher, timestamp) Storage model for DHT items, which is serialized to JSON before being passed to the storage adapter Parameters: Name Type Description key String Lookup key value String | Object | Array Stored value publisher String Original publisher's nodeID timestamp Number Optional UNIX timestamp of original publication Source: lib/item.js, line 15 × Search results Close Documentation generated by JSDoc 3.4.3 using the DocStrap template. "},"Logger.html":{"id":"Logger.html","title":"Class: Logger","body":" KadTools Modules kadkad/constantskad/contactskad/hookskad/storagekad/transportskad/utils Classes AddressPortContactBucketContactHTTPTransportItemLoggerMessagekad/storage.FSkad/storage.LocalStoragekad/storage.MemStoreNodeRouterRPCTCPTransportUDPTransport Events HTTPTransport#event:CONTACT_SEENHTTPTransport#event:FIND_NODEHTTPTransport#event:FIND_VALUEHTTPTransport#event:MESSAGE_DROPHTTPTransport#event:PINGHTTPTransport#event:readyHTTPTransport#event:STOREHTTPTransport#event:TIMEOUTNode#event:connectNode#event:disconnectNode#event:errorNode#event:joinNode#event:leaveRouter#event:addRouter#event:dropRouter#event:shiftRPC#event:CONTACT_SEENRPC#event:FIND_NODERPC#event:FIND_VALUERPC#event:MESSAGE_DROPRPC#event:PINGRPC#event:readyRPC#event:STORERPC#event:TIMEOUTTCPTransport#event:CONTACT_SEENTCPTransport#event:FIND_NODETCPTransport#event:FIND_VALUETCPTransport#event:MESSAGE_DROPTCPTransport#event:PINGTCPTransport#event:readyTCPTransport#event:STORETCPTransport#event:TIMEOUTUDPTransport#event:CONTACT_SEENUDPTransport#event:FIND_NODEUDPTransport#event:FIND_VALUEUDPTransport#event:MESSAGE_DROPUDPTransport#event:PINGUDPTransport#event:readyUDPTransport#event:STOREUDPTransport#event:TIMEOUT Tutorials Custom ContactsCustom Storage AdaptersCustom Transport AdaptersProtocol SpecificationUsing Hooks Externals kad-fskad-localstoragekad-memstore Class: Logger Logger new Logger(level, prefix) Kad, by default, prints log messages to the console using pretty-printed status messages. There are different types of messages indicating the nature or severity, `error`, `warn`, `info`, `debug`. You can tell Kad which of these messages types you want to see by passing a Logger with option from 0 - 4. Parameters: Name Type Description level Number Log verbosity (0-4) prefix String Optional prefix for log output Source: lib/logger.js, line 15 × Search results Close Documentation generated by JSDoc 3.4.3 using the DocStrap template. "},"Message.html":{"id":"Message.html","title":"Class: Message","body":" KadTools Modules kadkad/constantskad/contactskad/hookskad/storagekad/transportskad/utils Classes AddressPortContactBucketContactHTTPTransportItemLoggerMessagekad/storage.FSkad/storage.LocalStoragekad/storage.MemStoreNodeRouterRPCTCPTransportUDPTransport Events HTTPTransport#event:CONTACT_SEENHTTPTransport#event:FIND_NODEHTTPTransport#event:FIND_VALUEHTTPTransport#event:MESSAGE_DROPHTTPTransport#event:PINGHTTPTransport#event:readyHTTPTransport#event:STOREHTTPTransport#event:TIMEOUTNode#event:connectNode#event:disconnectNode#event:errorNode#event:joinNode#event:leaveRouter#event:addRouter#event:dropRouter#event:shiftRPC#event:CONTACT_SEENRPC#event:FIND_NODERPC#event:FIND_VALUERPC#event:MESSAGE_DROPRPC#event:PINGRPC#event:readyRPC#event:STORERPC#event:TIMEOUTTCPTransport#event:CONTACT_SEENTCPTransport#event:FIND_NODETCPTransport#event:FIND_VALUETCPTransport#event:MESSAGE_DROPTCPTransport#event:PINGTCPTransport#event:readyTCPTransport#event:STORETCPTransport#event:TIMEOUTUDPTransport#event:CONTACT_SEENUDPTransport#event:FIND_NODEUDPTransport#event:FIND_VALUEUDPTransport#event:MESSAGE_DROPUDPTransport#event:PINGUDPTransport#event:readyUDPTransport#event:STOREUDPTransport#event:TIMEOUT Tutorials Custom ContactsCustom Storage AdaptersCustom Transport AdaptersProtocol SpecificationUsing Hooks Externals kad-fskad-localstoragekad-memstore Class: Message Message new Message(spec) Represents a [JSON-RPC 2.0](http://www.jsonrpc.org/specification) request or response; used by RPC#send. Note that the value of the contact property will be replaced by the Contact your implementation uses. The decision to use JSON-RPC as the message format was made to allow for other language implementations and services to easily communicate with the network, using a widely recognized and used format. Parameters: Name Type Description spec Object Properties Name Type Description id String Message ID method String Method name to include in request message params Object Named parameters for request message result Object Result data for response message error Error Error object to convert to message Source: lib/message.js, line 25 Methods &lt;static&gt; createID() Returns a message id Source: lib/message.js, line 96 Returns: Type String &lt;static&gt; fromBuffer(buffer) Create a Message instance from a buffer Parameters: Name Type Description buffer Buffer Binary blob to convert to message object Source: lib/message.js, line 81 Returns: Type Message &lt;static&gt; isRequest(message) Returns a boolean indicating if this message is a request Parameters: Name Type Description message Message Message instance to inspect Source: lib/message.js, line 63 Returns: Type Boolean &lt;static&gt; isResponse(message) Returns a boolean indicating if this message is a response Parameters: Name Type Description message Message Message instance to inspect Source: lib/message.js, line 72 Returns: Type Boolean serialize() Serialize message to a Buffer Source: lib/message.js, line 54 Returns: Type Buffer × Search results Close Documentation generated by JSDoc 3.4.3 using the DocStrap template. "},"module-kad.html":{"id":"module-kad.html","title":"Module: kad","body":" KadTools Modules kadkad/constantskad/contactskad/hookskad/storagekad/transportskad/utils Classes AddressPortContactBucketContactHTTPTransportItemLoggerMessagekad/storage.FSkad/storage.LocalStoragekad/storage.MemStoreNodeRouterRPCTCPTransportUDPTransport Events HTTPTransport#event:CONTACT_SEENHTTPTransport#event:FIND_NODEHTTPTransport#event:FIND_VALUEHTTPTransport#event:MESSAGE_DROPHTTPTransport#event:PINGHTTPTransport#event:readyHTTPTransport#event:STOREHTTPTransport#event:TIMEOUTNode#event:connectNode#event:disconnectNode#event:errorNode#event:joinNode#event:leaveRouter#event:addRouter#event:dropRouter#event:shiftRPC#event:CONTACT_SEENRPC#event:FIND_NODERPC#event:FIND_VALUERPC#event:MESSAGE_DROPRPC#event:PINGRPC#event:readyRPC#event:STORERPC#event:TIMEOUTTCPTransport#event:CONTACT_SEENTCPTransport#event:FIND_NODETCPTransport#event:FIND_VALUETCPTransport#event:MESSAGE_DROPTCPTransport#event:PINGTCPTransport#event:readyTCPTransport#event:STORETCPTransport#event:TIMEOUTUDPTransport#event:CONTACT_SEENUDPTransport#event:FIND_NODEUDPTransport#event:FIND_VALUEUDPTransport#event:MESSAGE_DROPUDPTransport#event:PINGUDPTransport#event:readyUDPTransport#event:STOREUDPTransport#event:TIMEOUT Tutorials Custom ContactsCustom Storage AdaptersCustom Transport AdaptersProtocol SpecificationUsing Hooks Externals kad-fskad-localstoragekad-memstore Module: kad Author: Gordon Hall gordon@gordonwritescode.com License: GPL-3.0 Source: index.js, line 1 Members &lt;static&gt; Bucket Bucket Source: index.js, line 10 &lt;static&gt; constants module:kad/constants Source: index.js, line 46 &lt;static&gt; Contact Contact Source: index.js, line 13 &lt;static&gt; contacts module:kad/contacts Source: index.js, line 31 &lt;static&gt; hooks module:kad/hooks Source: index.js, line 37 &lt;static&gt; Logger Logger Source: index.js, line 16 &lt;static&gt; Message Message Source: index.js, line 19 &lt;static&gt; Node Node Source: index.js, line 22 &lt;static&gt; Router Router Source: index.js, line 25 &lt;static&gt; RPC RPC Source: index.js, line 28 &lt;static&gt; storage module:kad.storage Source: index.js, line 40 &lt;static&gt; transports module:kad/transports Source: index.js, line 34 &lt;static&gt; utils module:kad/utils Source: index.js, line 43 × Search results Close Documentation generated by JSDoc 3.4.3 using the DocStrap template. "},"module-kad_constants.html":{"id":"module-kad_constants.html","title":"Module: kad/constants","body":" KadTools Modules kadkad/constantskad/contactskad/hookskad/storagekad/transportskad/utils Classes AddressPortContactBucketContactHTTPTransportItemLoggerMessagekad/storage.FSkad/storage.LocalStoragekad/storage.MemStoreNodeRouterRPCTCPTransportUDPTransport Events HTTPTransport#event:CONTACT_SEENHTTPTransport#event:FIND_NODEHTTPTransport#event:FIND_VALUEHTTPTransport#event:MESSAGE_DROPHTTPTransport#event:PINGHTTPTransport#event:readyHTTPTransport#event:STOREHTTPTransport#event:TIMEOUTNode#event:connectNode#event:disconnectNode#event:errorNode#event:joinNode#event:leaveRouter#event:addRouter#event:dropRouter#event:shiftRPC#event:CONTACT_SEENRPC#event:FIND_NODERPC#event:FIND_VALUERPC#event:MESSAGE_DROPRPC#event:PINGRPC#event:readyRPC#event:STORERPC#event:TIMEOUTTCPTransport#event:CONTACT_SEENTCPTransport#event:FIND_NODETCPTransport#event:FIND_VALUETCPTransport#event:MESSAGE_DROPTCPTransport#event:PINGTCPTransport#event:readyTCPTransport#event:STORETCPTransport#event:TIMEOUTUDPTransport#event:CONTACT_SEENUDPTransport#event:FIND_NODEUDPTransport#event:FIND_VALUEUDPTransport#event:MESSAGE_DROPUDPTransport#event:PINGUDPTransport#event:readyUDPTransport#event:STOREUDPTransport#event:TIMEOUT Tutorials Custom ContactsCustom Storage AdaptersCustom Transport AdaptersProtocol SpecificationUsing Hooks Externals kad-fskad-localstoragekad-memstore Module: kad/constants Source: lib/constants.js, line 1 Members &lt;inner, constant&gt; ALPHA :Number Degree of parallelism Type: Number Source: lib/constants.js, line 11 &lt;inner, constant&gt; B :Number Number of bits for nodeID creation Type: Number Source: lib/constants.js, line 14 &lt;inner, constant&gt; K :Number Number of contacts held in a bucket Type: Number Source: lib/constants.js, line 17 &lt;inner, constant&gt; MESSAGE_TYPES :Array Allowed RPC methods Type: Array Source: lib/constants.js, line 35 &lt;inner, constant&gt; T_EXPIRE :Number Interval for expiring local data entries Type: Number Source: lib/constants.js, line 29 &lt;inner, constant&gt; T_REFRESH :Number Interval for performing router refresh Type: Number Source: lib/constants.js, line 20 &lt;inner, constant&gt; T_REPLICATE :Number Interval for replicating local data Type: Number Source: lib/constants.js, line 23 &lt;inner, constant&gt; T_REPUBLISH :Number Interval for republishing data Type: Number Source: lib/constants.js, line 26 &lt;inner, constant&gt; T_RESPONSETIMEOUT :Number Time to wait for RPC response Type: Number Source: lib/constants.js, line 32 × Search results Close Documentation generated by JSDoc 3.4.3 using the DocStrap template. "},"module-kad_contacts.html":{"id":"module-kad_contacts.html","title":"Module: kad/contacts","body":" KadTools Modules kadkad/constantskad/contactskad/hookskad/storagekad/transportskad/utils Classes AddressPortContactBucketContactHTTPTransportItemLoggerMessagekad/storage.FSkad/storage.LocalStoragekad/storage.MemStoreNodeRouterRPCTCPTransportUDPTransport Events HTTPTransport#event:CONTACT_SEENHTTPTransport#event:FIND_NODEHTTPTransport#event:FIND_VALUEHTTPTransport#event:MESSAGE_DROPHTTPTransport#event:PINGHTTPTransport#event:readyHTTPTransport#event:STOREHTTPTransport#event:TIMEOUTNode#event:connectNode#event:disconnectNode#event:errorNode#event:joinNode#event:leaveRouter#event:addRouter#event:dropRouter#event:shiftRPC#event:CONTACT_SEENRPC#event:FIND_NODERPC#event:FIND_VALUERPC#event:MESSAGE_DROPRPC#event:PINGRPC#event:readyRPC#event:STORERPC#event:TIMEOUTTCPTransport#event:CONTACT_SEENTCPTransport#event:FIND_NODETCPTransport#event:FIND_VALUETCPTransport#event:MESSAGE_DROPTCPTransport#event:PINGTCPTransport#event:readyTCPTransport#event:STORETCPTransport#event:TIMEOUTUDPTransport#event:CONTACT_SEENUDPTransport#event:FIND_NODEUDPTransport#event:FIND_VALUEUDPTransport#event:MESSAGE_DROPUDPTransport#event:PINGUDPTransport#event:readyUDPTransport#event:STOREUDPTransport#event:TIMEOUT Tutorials Custom ContactsCustom Storage AdaptersCustom Transport AdaptersProtocol SpecificationUsing Hooks Externals kad-fskad-localstoragekad-memstore Module: kad/contacts Source: lib/contacts/index.js, line 1 Members &lt;static&gt; AddressPortContact AddressPortContact Source: lib/contacts/index.js, line 9 × Search results Close Documentation generated by JSDoc 3.4.3 using the DocStrap template. "},"module-kad_hooks.html":{"id":"module-kad_hooks.html","title":"Module: kad/hooks","body":" KadTools Modules kadkad/constantskad/contactskad/hookskad/storagekad/transportskad/utils Classes AddressPortContactBucketContactHTTPTransportItemLoggerMessagekad/storage.FSkad/storage.LocalStoragekad/storage.MemStoreNodeRouterRPCTCPTransportUDPTransport Events HTTPTransport#event:CONTACT_SEENHTTPTransport#event:FIND_NODEHTTPTransport#event:FIND_VALUEHTTPTransport#event:MESSAGE_DROPHTTPTransport#event:PINGHTTPTransport#event:readyHTTPTransport#event:STOREHTTPTransport#event:TIMEOUTNode#event:connectNode#event:disconnectNode#event:errorNode#event:joinNode#event:leaveRouter#event:addRouter#event:dropRouter#event:shiftRPC#event:CONTACT_SEENRPC#event:FIND_NODERPC#event:FIND_VALUERPC#event:MESSAGE_DROPRPC#event:PINGRPC#event:readyRPC#event:STORERPC#event:TIMEOUTTCPTransport#event:CONTACT_SEENTCPTransport#event:FIND_NODETCPTransport#event:FIND_VALUETCPTransport#event:MESSAGE_DROPTCPTransport#event:PINGTCPTransport#event:readyTCPTransport#event:STORETCPTransport#event:TIMEOUTUDPTransport#event:CONTACT_SEENUDPTransport#event:FIND_NODEUDPTransport#event:FIND_VALUEUDPTransport#event:MESSAGE_DROPUDPTransport#event:PINGUDPTransport#event:readyUDPTransport#event:STOREUDPTransport#event:TIMEOUT Tutorials Custom ContactsCustom Storage AdaptersCustom Transport AdaptersProtocol SpecificationUsing Hooks Externals kad-fskad-localstoragekad-memstore Module: kad/hooks Source: lib/hooks/index.js, line 1 Methods &lt;static&gt; blacklist(nodeIDs) Creates a blacklist filter for rejecting messages from defined nodeIDs Parameters: Name Type Description nodeIDs Array List of nodeIDs to blacklist Source: lib/hooks/index.js, line 14 Returns: Type function &lt;static&gt; protocol(protocol) Allows the definition of method handlers not defined by kademlia Parameters: Name Type Description protocol Object Hash map of : Source: lib/hooks/index.js, line 28 Returns: Type function &lt;static&gt; whitelist(nodeIDs) Creates a whitelist filter for accepting messages from defined nodeIDs Parameters: Name Type Description nodeIDs Array List of nodeIDs to whitelist Source: lib/hooks/index.js, line 21 Returns: Type function × Search results Close Documentation generated by JSDoc 3.4.3 using the DocStrap template. "},"module-kad_storage.html":{"id":"module-kad_storage.html","title":"Module: kad/storage","body":" KadTools Modules kadkad/constantskad/contactskad/hookskad/storagekad/transportskad/utils Classes AddressPortContactBucketContactHTTPTransportItemLoggerMessagekad/storage.FSkad/storage.LocalStoragekad/storage.MemStoreNodeRouterRPCTCPTransportUDPTransport Events HTTPTransport#event:CONTACT_SEENHTTPTransport#event:FIND_NODEHTTPTransport#event:FIND_VALUEHTTPTransport#event:MESSAGE_DROPHTTPTransport#event:PINGHTTPTransport#event:readyHTTPTransport#event:STOREHTTPTransport#event:TIMEOUTNode#event:connectNode#event:disconnectNode#event:errorNode#event:joinNode#event:leaveRouter#event:addRouter#event:dropRouter#event:shiftRPC#event:CONTACT_SEENRPC#event:FIND_NODERPC#event:FIND_VALUERPC#event:MESSAGE_DROPRPC#event:PINGRPC#event:readyRPC#event:STORERPC#event:TIMEOUTTCPTransport#event:CONTACT_SEENTCPTransport#event:FIND_NODETCPTransport#event:FIND_VALUETCPTransport#event:MESSAGE_DROPTCPTransport#event:PINGTCPTransport#event:readyTCPTransport#event:STORETCPTransport#event:TIMEOUTUDPTransport#event:CONTACT_SEENUDPTransport#event:FIND_NODEUDPTransport#event:FIND_VALUEUDPTransport#event:MESSAGE_DROPUDPTransport#event:PINGUDPTransport#event:readyUDPTransport#event:STOREUDPTransport#event:TIMEOUT Tutorials Custom ContactsCustom Storage AdaptersCustom Transport AdaptersProtocol SpecificationUsing Hooks Externals kad-fskad-localstoragekad-memstore Module: kad/storage Source: lib/storage.js, line 1 Classes FS LocalStorage MemStore × Search results Close Documentation generated by JSDoc 3.4.3 using the DocStrap template. "},"module-kad_storage.FS.html":{"id":"module-kad_storage.FS.html","title":"Class: FS","body":" KadTools Modules kadkad/constantskad/contactskad/hookskad/storagekad/transportskad/utils Classes AddressPortContactBucketContactHTTPTransportItemLoggerMessagekad/storage.FSkad/storage.LocalStoragekad/storage.MemStoreNodeRouterRPCTCPTransportUDPTransport Events HTTPTransport#event:CONTACT_SEENHTTPTransport#event:FIND_NODEHTTPTransport#event:FIND_VALUEHTTPTransport#event:MESSAGE_DROPHTTPTransport#event:PINGHTTPTransport#event:readyHTTPTransport#event:STOREHTTPTransport#event:TIMEOUTNode#event:connectNode#event:disconnectNode#event:errorNode#event:joinNode#event:leaveRouter#event:addRouter#event:dropRouter#event:shiftRPC#event:CONTACT_SEENRPC#event:FIND_NODERPC#event:FIND_VALUERPC#event:MESSAGE_DROPRPC#event:PINGRPC#event:readyRPC#event:STORERPC#event:TIMEOUTTCPTransport#event:CONTACT_SEENTCPTransport#event:FIND_NODETCPTransport#event:FIND_VALUETCPTransport#event:MESSAGE_DROPTCPTransport#event:PINGTCPTransport#event:readyTCPTransport#event:STORETCPTransport#event:TIMEOUTUDPTransport#event:CONTACT_SEENUDPTransport#event:FIND_NODEUDPTransport#event:FIND_VALUEUDPTransport#event:MESSAGE_DROPUDPTransport#event:PINGUDPTransport#event:readyUDPTransport#event:STOREUDPTransport#event:TIMEOUT Tutorials Custom ContactsCustom Storage AdaptersCustom Transport AdaptersProtocol SpecificationUsing Hooks Externals kad-fskad-localstoragekad-memstore Class: FS kad/storage. FS new FS(datadir) Stores Item as file in the specified directory Parameters: Name Type Description datadir String Directory to store items Source: lib/storage.js, line 18 × Search results Close Documentation generated by JSDoc 3.4.3 using the DocStrap template. "},"module-kad_storage.LocalStorage.html":{"id":"module-kad_storage.LocalStorage.html","title":"Class: LocalStorage","body":" KadTools Modules kadkad/constantskad/contactskad/hookskad/storagekad/transportskad/utils Classes AddressPortContactBucketContactHTTPTransportItemLoggerMessagekad/storage.FSkad/storage.LocalStoragekad/storage.MemStoreNodeRouterRPCTCPTransportUDPTransport Events HTTPTransport#event:CONTACT_SEENHTTPTransport#event:FIND_NODEHTTPTransport#event:FIND_VALUEHTTPTransport#event:MESSAGE_DROPHTTPTransport#event:PINGHTTPTransport#event:readyHTTPTransport#event:STOREHTTPTransport#event:TIMEOUTNode#event:connectNode#event:disconnectNode#event:errorNode#event:joinNode#event:leaveRouter#event:addRouter#event:dropRouter#event:shiftRPC#event:CONTACT_SEENRPC#event:FIND_NODERPC#event:FIND_VALUERPC#event:MESSAGE_DROPRPC#event:PINGRPC#event:readyRPC#event:STORERPC#event:TIMEOUTTCPTransport#event:CONTACT_SEENTCPTransport#event:FIND_NODETCPTransport#event:FIND_VALUETCPTransport#event:MESSAGE_DROPTCPTransport#event:PINGTCPTransport#event:readyTCPTransport#event:STORETCPTransport#event:TIMEOUTUDPTransport#event:CONTACT_SEENUDPTransport#event:FIND_NODEUDPTransport#event:FIND_VALUEUDPTransport#event:MESSAGE_DROPUDPTransport#event:PINGUDPTransport#event:readyUDPTransport#event:STOREUDPTransport#event:TIMEOUT Tutorials Custom ContactsCustom Storage AdaptersCustom Transport AdaptersProtocol SpecificationUsing Hooks Externals kad-fskad-localstoragekad-memstore Class: LocalStorage kad/storage. LocalStorage new LocalStorage(namespace) Stores Item in browser localStorage using the given namespace Parameters: Name Type Description namespace String Prefix for keys in localStorage Source: lib/storage.js, line 29 × Search results Close Documentation generated by JSDoc 3.4.3 using the DocStrap template. "},"module-kad_storage.MemStore.html":{"id":"module-kad_storage.MemStore.html","title":"Class: MemStore","body":" KadTools Modules kadkad/constantskad/contactskad/hookskad/storagekad/transportskad/utils Classes AddressPortContactBucketContactHTTPTransportItemLoggerMessagekad/storage.FSkad/storage.LocalStoragekad/storage.MemStoreNodeRouterRPCTCPTransportUDPTransport Events HTTPTransport#event:CONTACT_SEENHTTPTransport#event:FIND_NODEHTTPTransport#event:FIND_VALUEHTTPTransport#event:MESSAGE_DROPHTTPTransport#event:PINGHTTPTransport#event:readyHTTPTransport#event:STOREHTTPTransport#event:TIMEOUTNode#event:connectNode#event:disconnectNode#event:errorNode#event:joinNode#event:leaveRouter#event:addRouter#event:dropRouter#event:shiftRPC#event:CONTACT_SEENRPC#event:FIND_NODERPC#event:FIND_VALUERPC#event:MESSAGE_DROPRPC#event:PINGRPC#event:readyRPC#event:STORERPC#event:TIMEOUTTCPTransport#event:CONTACT_SEENTCPTransport#event:FIND_NODETCPTransport#event:FIND_VALUETCPTransport#event:MESSAGE_DROPTCPTransport#event:PINGTCPTransport#event:readyTCPTransport#event:STORETCPTransport#event:TIMEOUTUDPTransport#event:CONTACT_SEENUDPTransport#event:FIND_NODEUDPTransport#event:FIND_VALUEUDPTransport#event:MESSAGE_DROPUDPTransport#event:PINGUDPTransport#event:readyUDPTransport#event:STOREUDPTransport#event:TIMEOUT Tutorials Custom ContactsCustom Storage AdaptersCustom Transport AdaptersProtocol SpecificationUsing Hooks Externals kad-fskad-localstoragekad-memstore Class: MemStore kad/storage. MemStore new MemStore() Stores Item in memory for testing Source: lib/storage.js, line 39 × Search results Close Documentation generated by JSDoc 3.4.3 using the DocStrap template. "},"module-kad_transports.html":{"id":"module-kad_transports.html","title":"Module: kad/transports","body":" KadTools Modules kadkad/constantskad/contactskad/hookskad/storagekad/transportskad/utils Classes AddressPortContactBucketContactHTTPTransportItemLoggerMessagekad/storage.FSkad/storage.LocalStoragekad/storage.MemStoreNodeRouterRPCTCPTransportUDPTransport Events HTTPTransport#event:CONTACT_SEENHTTPTransport#event:FIND_NODEHTTPTransport#event:FIND_VALUEHTTPTransport#event:MESSAGE_DROPHTTPTransport#event:PINGHTTPTransport#event:readyHTTPTransport#event:STOREHTTPTransport#event:TIMEOUTNode#event:connectNode#event:disconnectNode#event:errorNode#event:joinNode#event:leaveRouter#event:addRouter#event:dropRouter#event:shiftRPC#event:CONTACT_SEENRPC#event:FIND_NODERPC#event:FIND_VALUERPC#event:MESSAGE_DROPRPC#event:PINGRPC#event:readyRPC#event:STORERPC#event:TIMEOUTTCPTransport#event:CONTACT_SEENTCPTransport#event:FIND_NODETCPTransport#event:FIND_VALUETCPTransport#event:MESSAGE_DROPTCPTransport#event:PINGTCPTransport#event:readyTCPTransport#event:STORETCPTransport#event:TIMEOUTUDPTransport#event:CONTACT_SEENUDPTransport#event:FIND_NODEUDPTransport#event:FIND_VALUEUDPTransport#event:MESSAGE_DROPUDPTransport#event:PINGUDPTransport#event:readyUDPTransport#event:STOREUDPTransport#event:TIMEOUT Tutorials Custom ContactsCustom Storage AdaptersCustom Transport AdaptersProtocol SpecificationUsing Hooks Externals kad-fskad-localstoragekad-memstore Module: kad/transports Source: lib/transports/index.js, line 1 Members &lt;static&gt; HTTP HTTPTransport Source: lib/transports/index.js, line 13 &lt;static&gt; TCP TCPTransport Source: lib/transports/index.js, line 9 &lt;static&gt; UDP UDPTransport Source: lib/transports/index.js, line 11 × Search results Close Documentation generated by JSDoc 3.4.3 using the DocStrap template. "},"module-kad_utils.html":{"id":"module-kad_utils.html","title":"Module: kad/utils","body":" KadTools Modules kadkad/constantskad/contactskad/hookskad/storagekad/transportskad/utils Classes AddressPortContactBucketContactHTTPTransportItemLoggerMessagekad/storage.FSkad/storage.LocalStoragekad/storage.MemStoreNodeRouterRPCTCPTransportUDPTransport Events HTTPTransport#event:CONTACT_SEENHTTPTransport#event:FIND_NODEHTTPTransport#event:FIND_VALUEHTTPTransport#event:MESSAGE_DROPHTTPTransport#event:PINGHTTPTransport#event:readyHTTPTransport#event:STOREHTTPTransport#event:TIMEOUTNode#event:connectNode#event:disconnectNode#event:errorNode#event:joinNode#event:leaveRouter#event:addRouter#event:dropRouter#event:shiftRPC#event:CONTACT_SEENRPC#event:FIND_NODERPC#event:FIND_VALUERPC#event:MESSAGE_DROPRPC#event:PINGRPC#event:readyRPC#event:STORERPC#event:TIMEOUTTCPTransport#event:CONTACT_SEENTCPTransport#event:FIND_NODETCPTransport#event:FIND_VALUETCPTransport#event:MESSAGE_DROPTCPTransport#event:PINGTCPTransport#event:readyTCPTransport#event:STORETCPTransport#event:TIMEOUTUDPTransport#event:CONTACT_SEENUDPTransport#event:FIND_NODEUDPTransport#event:FIND_VALUEUDPTransport#event:MESSAGE_DROPUDPTransport#event:PINGUDPTransport#event:readyUDPTransport#event:STOREUDPTransport#event:TIMEOUT Tutorials Custom ContactsCustom Storage AdaptersCustom Transport AdaptersProtocol SpecificationUsing Hooks Externals kad-fskad-localstoragekad-memstore Module: kad/utils Source: lib/utils.js, line 1 Methods &lt;static&gt; compareKeys(b1, b2) Compare two buffers for sorting Parameters: Name Type Description b1 Buffer b2 Buffer Source: lib/utils.js, line 71 Returns: Type Number &lt;static&gt; createID(data) Create a valid ID from the given string Parameters: Name Type Description data String | Buffer Data to SHA1 hash Source: lib/utils.js, line 25 Returns: Type String &lt;static&gt; getBucketIndex(id1, id2) Calculate the index of the bucket that key would belong to Parameters: Name Type Description id1 String id2 String Source: lib/utils.js, line 93 Returns: Type Number &lt;static&gt; getDistance(key1, key2) Calculate the distance between two keys Parameters: Name Type Description key1 String key2 String Source: lib/utils.js, line 50 Returns: Type Number &lt;static&gt; getRandomInBucketRangeBuffer(index) Assuming index corresponds to power of 2 (index = n has nodes within distance 2^n Parameters: Name Type Description index Number Source: lib/utils.js, line 141 &lt;static&gt; hexToBuffer(hexString) Convert a key to a buffer Parameters: Name Type Description hexString String Source: lib/utils.js, line 38 Returns: Type Buffer &lt;static&gt; isValidKey(key) Validate a key Parameters: Name Type Description key String Key to test Source: lib/utils.js, line 16 Returns: Type Boolean × Search results Close Documentation generated by JSDoc 3.4.3 using the DocStrap template. "},"Node.html":{"id":"Node.html","title":"Class: Node","body":" KadTools Modules kadkad/constantskad/contactskad/hookskad/storagekad/transportskad/utils Classes AddressPortContactBucketContactHTTPTransportItemLoggerMessagekad/storage.FSkad/storage.LocalStoragekad/storage.MemStoreNodeRouterRPCTCPTransportUDPTransport Events HTTPTransport#event:CONTACT_SEENHTTPTransport#event:FIND_NODEHTTPTransport#event:FIND_VALUEHTTPTransport#event:MESSAGE_DROPHTTPTransport#event:PINGHTTPTransport#event:readyHTTPTransport#event:STOREHTTPTransport#event:TIMEOUTNode#event:connectNode#event:disconnectNode#event:errorNode#event:joinNode#event:leaveRouter#event:addRouter#event:dropRouter#event:shiftRPC#event:CONTACT_SEENRPC#event:FIND_NODERPC#event:FIND_VALUERPC#event:MESSAGE_DROPRPC#event:PINGRPC#event:readyRPC#event:STORERPC#event:TIMEOUTTCPTransport#event:CONTACT_SEENTCPTransport#event:FIND_NODETCPTransport#event:FIND_VALUETCPTransport#event:MESSAGE_DROPTCPTransport#event:PINGTCPTransport#event:readyTCPTransport#event:STORETCPTransport#event:TIMEOUTUDPTransport#event:CONTACT_SEENUDPTransport#event:FIND_NODEUDPTransport#event:FIND_VALUEUDPTransport#event:MESSAGE_DROPUDPTransport#event:PINGUDPTransport#event:readyUDPTransport#event:STOREUDPTransport#event:TIMEOUT Tutorials Custom ContactsCustom Storage AdaptersCustom Transport AdaptersProtocol SpecificationUsing Hooks Externals kad-fskad-localstoragekad-memstore Class: Node Node new Node(options) Represents a Kademlia node Parameters: Name Type Description options Object Properties Name Type Description router Router Custom router instance to use transport RPC Transport (RPC) adapter to use storage Object Storage adapter to use logger Logger Logger instance to use validator Node~validator Key-Value validation function Source: lib/node.js, line 29 Fires: Node#event:join Node#event:leave Node#event:connect Node#event:disconnect Node#event:error Methods connect(contact, callback) Connects to the overlay network Parameters: Name Type Description contact Contact Contact object to use for entering network callback Node~connectCallback Optional callback on connect Source: lib/node.js, line 107 Returns: Type Node disconnect(callback) Disconnects from the overlay by closing the transport and emptying the routing table Parameters: Name Type Description callback Node~disconnectCallback Optional callback on disconnect Source: lib/node.js, line 148 get(key, callback) Get a value by it's key from the DHT Parameters: Name Type Description key String Lookup key for the stored value callback function Source: lib/node.js, line 198 put(key, value, callback) Set a key/value pair in the DHT Parameters: Name Type Description key String Lookup key for the value to store value String Data to store in the DHT callback Node~putCallback Executed upon completion Source: lib/node.js, line 173 Type Definitions connectCallback(err, contact) This callback is called upon completion of Node#connect Parameters: Name Type Description err Error | null The error object, if any contact Contact The Contact passed to Node#connect Source: lib/node.js, line 136 disconnectCallback() This callback is called upon completion of Node#disconnect Source: lib/node.js, line 162 getCallback(err, value) This callback is called upon completion of Node#get Parameters: Name Type Description err Error | null The error object, if any value String The value retrieved from the DHT Source: lib/node.js, line 220 putCallback(err) This callback is called upon completion of Node#put Parameters: Name Type Description err Error | null The error object, if any Source: lib/node.js, line 187 validator(key, value, callback) Called when a value is retrieved or stored to validate the pair Parameters: Name Type Description key String The key at which the value is or should be stored value String The returned or stored value callback function Called with boolean indicating validity Source: lib/node.js, line 56 Events connect Aliases Node#event:join for backwards compatibility; use one or the other, but not both Deprecated: since version 1.4.0, use Node#event:join instead Source: lib/node.js, line 74 disconnect Aliases Node#event:leave for backwards compatibility; use one or the other, but not both Deprecated: since version 1.4.0, use Node#event:leave instead Source: lib/node.js, line 81 error Error event fires when a critical failure has occurred; if no handler is specified, then it will throw Type: Error Source: lib/node.js, line 88 join Join event is triggered when the routing table is no longer empty Source: lib/node.js, line 64 leave Leave event is triggered when the routing table becomes empty Source: lib/node.js, line 69 × Search results Close Documentation generated by JSDoc 3.4.3 using the DocStrap template. "},"Router.html":{"id":"Router.html","title":"Class: Router","body":" KadTools Modules kadkad/constantskad/contactskad/hookskad/storagekad/transportskad/utils Classes AddressPortContactBucketContactHTTPTransportItemLoggerMessagekad/storage.FSkad/storage.LocalStoragekad/storage.MemStoreNodeRouterRPCTCPTransportUDPTransport Events HTTPTransport#event:CONTACT_SEENHTTPTransport#event:FIND_NODEHTTPTransport#event:FIND_VALUEHTTPTransport#event:MESSAGE_DROPHTTPTransport#event:PINGHTTPTransport#event:readyHTTPTransport#event:STOREHTTPTransport#event:TIMEOUTNode#event:connectNode#event:disconnectNode#event:errorNode#event:joinNode#event:leaveRouter#event:addRouter#event:dropRouter#event:shiftRPC#event:CONTACT_SEENRPC#event:FIND_NODERPC#event:FIND_VALUERPC#event:MESSAGE_DROPRPC#event:PINGRPC#event:readyRPC#event:STORERPC#event:TIMEOUTTCPTransport#event:CONTACT_SEENTCPTransport#event:FIND_NODETCPTransport#event:FIND_VALUETCPTransport#event:MESSAGE_DROPTCPTransport#event:PINGTCPTransport#event:readyTCPTransport#event:STORETCPTransport#event:TIMEOUTUDPTransport#event:CONTACT_SEENUDPTransport#event:FIND_NODEUDPTransport#event:FIND_VALUEUDPTransport#event:MESSAGE_DROPUDPTransport#event:PINGUDPTransport#event:readyUDPTransport#event:STOREUDPTransport#event:TIMEOUT Tutorials Custom ContactsCustom Storage AdaptersCustom Transport AdaptersProtocol SpecificationUsing Hooks Externals kad-fskad-localstoragekad-memstore Class: Router Router new Router(options) Represents a routing table of known Contacts; used by Node. Parameters: Name Type Description options Object Properties Name Type Description logger Logger Logger instance to use transport RPC Transport adapter (RPC) to use validator Router~validator Key-Value validation function Source: lib/router.js, line 27 Fires: Router#event:add Router#event:drop Router#event:shift Methods empty() Empties the routing table, clearing all known contacts Source: lib/router.js, line 126 findNode(nodeID [, options], callback) Search contacts for nodes close to the given key Parameters: Name Type Argument Description nodeID String The nodeID the search for neighbors options Object &lt;optional&gt; Properties Name Type Argument Default Description aggressiveLookup Boolean &lt;optional&gt; false Iterate until K contacts are found even if there is no improvement aggressiveCache Boolean &lt;optional&gt; false Try to add all results from any FIND_NODE RPC to the routing table callback Router~findNodeCallback Called upon lookup completion Source: lib/router.js, line 528 findValue(key, callback) Search contacts for the value at given key Parameters: Name Type Description key String The lookup key for the desired value callback Router~findValueCallback Called upon lookup completion Source: lib/router.js, line 496 getContactByNodeID(nodeID) Returns the Contact in the routing table by the given node ID Parameters: Name Type Description nodeID String The nodeID of the Contact to return Source: lib/router.js, line 158 Returns: Type Contact | null getNearestContacts(key, limit, nodeID) Return contacts closest to the given key Parameters: Name Type Description key String Lookup key for getting close Contacts limit Number Maximum number of contacts to return nodeID String Node ID to exclude from results Source: lib/router.js, line 686 Returns: Type Array lookup(type, key, callback [, aggressiveLookup]) Execute this router's find operation with the shortlist Parameters: Name Type Argument Default Description type String One of &quot;NODE&quot; or &quot;VALUE&quot; key String Key to use for lookup callback Router~lookupCallback Called when the lookup is complete aggressiveLookup Boolean &lt;optional&gt; false Iterate until K contacts are found even if there is no improvement Source: lib/router.js, line 81 refreshBucket(index, callback) Refreshes the bucket at the given index Parameters: Name Type Description index Number callback function Source: lib/router.js, line 478 refreshBucketsBeyondClosest(contacts, done) Refreshes the buckets farther than the closest known Parameters: Name Type Description contacts Array Results returned from findNode() done Router~refreshBeyondCallback Called upon successful refresh Source: lib/router.js, line 448 removeContact(contact) Removes the given contact from the routing table Parameters: Name Type Description contact Contact The contact to drop from the router Source: lib/router.js, line 136 Returns: Operation succeeded (contact was in expected bucket) Type Boolean updateContact(contact, callback) Update the contact's status Parameters: Name Type Description contact Contact Contact to update callback Router~updateContactCallback Optional completion calback Source: lib/router.js, line 568 Returns: Type Contact Type Definitions findNodeCallback(err, value) This callback is called upon completion of Router#findNode Parameters: Name Type Description err Error | null The error object, if any value Array The Contacts returned from the lookup Source: lib/router.js, line 555 findValueCallback(err, value) This callback is called upon completion of Router#findValue Parameters: Name Type Description err Error | null The error object, if any value String The value returned from the lookup Source: lib/router.js, line 511 lookupCallback(err, type, result) This callback is called upon completion of Router#lookup Parameters: Name Type Description err Error | null The error object, if any type String One of &quot;NODE&quot; or &quot;VALUE&quot; result Array | String The Contacts returned or the value Source: lib/router.js, line 100 refreshBeyondCallback() This callback is called upon completion of Router#refreshBucketsBeyondClosest Source: lib/router.js, line 467 refreshCallback(err, contacts) This callback is called upon completion of Router#refreshBucket Parameters: Name Type Description err Error | null The error object, if any contacts Array The list of Contacts refreshed Source: lib/router.js, line 484 updateContactCallback() This callback is called upon completion of Router#updateContact Source: lib/router.js, line 594 validator(key, value, callback) Called when a value is returned from a lookup to validate it Parameters: Name Type Description key String The key at which the value is stored value String The returned value from the lookup callback function Called with boolean indicating validity Source: lib/router.js, line 44 Events add Add event is triggered when a new Contact is added to the router Source: lib/router.js, line 52 drop Drop event is triggered when a Contact is dropped from the router Source: lib/router.js, line 57 shift Shift event is triggered when a Contact changes position in a Bucket Source: lib/router.js, line 62 × Search results Close Documentation generated by JSDoc 3.4.3 using the DocStrap template. "},"RPC.html":{"id":"RPC.html","title":"Class: RPC","body":" KadTools Modules kadkad/constantskad/contactskad/hookskad/storagekad/transportskad/utils Classes AddressPortContactBucketContactHTTPTransportItemLoggerMessagekad/storage.FSkad/storage.LocalStoragekad/storage.MemStoreNodeRouterRPCTCPTransportUDPTransport Events HTTPTransport#event:CONTACT_SEENHTTPTransport#event:FIND_NODEHTTPTransport#event:FIND_VALUEHTTPTransport#event:MESSAGE_DROPHTTPTransport#event:PINGHTTPTransport#event:readyHTTPTransport#event:STOREHTTPTransport#event:TIMEOUTNode#event:connectNode#event:disconnectNode#event:errorNode#event:joinNode#event:leaveRouter#event:addRouter#event:dropRouter#event:shiftRPC#event:CONTACT_SEENRPC#event:FIND_NODERPC#event:FIND_VALUERPC#event:MESSAGE_DROPRPC#event:PINGRPC#event:readyRPC#event:STORERPC#event:TIMEOUTTCPTransport#event:CONTACT_SEENTCPTransport#event:FIND_NODETCPTransport#event:FIND_VALUETCPTransport#event:MESSAGE_DROPTCPTransport#event:PINGTCPTransport#event:readyTCPTransport#event:STORETCPTransport#event:TIMEOUTUDPTransport#event:CONTACT_SEENUDPTransport#event:FIND_NODEUDPTransport#event:FIND_VALUEUDPTransport#event:MESSAGE_DROPUDPTransport#event:PINGUDPTransport#event:readyUDPTransport#event:STOREUDPTransport#event:TIMEOUT Tutorials Custom ContactsCustom Storage AdaptersCustom Transport AdaptersProtocol SpecificationUsing Hooks Externals kad-fskad-localstoragekad-memstore Class: RPC RPC new RPC(contact, options) Represents an RPC interface Parameters: Name Type Description contact Contact Your node's Contact information options Object Properties Name Type Description replyto Contact Optional alternate public contact logger Logger Logger instance to use Properties: Name Type Description readyState Number Closed: 0, Transitioning: 1, Open: 2 Source: lib/rpc.js, line 21 Methods &lt;abstract&gt; _close() Unimplemented stub, called on close() Source: lib/rpc.js, line 379 &lt;abstract&gt; _open() Unimplemented stub, called on constructor Source: lib/rpc.js, line 397 &lt;abstract&gt; _send(data, contact) Unimplemented stub, called on send() Parameters: Name Type Description data Buffer Raw binary data to send contact Contact Target peer to send data Source: lib/rpc.js, line 389 after(event, handler) Registers an &quot;after&quot; hook Parameters: Name Type Description event String Name of the event to catch handler function Event handler to register Source: lib/rpc.js, line 258 before(event, handler) Registers a &quot;before&quot; hook Parameters: Name Type Description event String Name of the event to catch handler function Event handler to register Source: lib/rpc.js, line 249 close(callback) Closes the underlying transport Parameters: Name Type Description callback RPC~closeCallback Called when the transport is closed Source: lib/rpc.js, line 128 open(callback) Opens the underlying transport Parameters: Name Type Description callback RPC~openCallback Called when the transport is opened Source: lib/rpc.js, line 97 Fires: RPC#event:ready receive(buffer) Handle incoming messages Parameters: Name Type Description buffer Buffer Raw binary data to be processed by the RPC handler Source: lib/rpc.js, line 203 send(contact, message, callback) Send a RPC to the given contact Parameters: Name Type Description contact Contact Delivery target for message message Message Message to send to target callback RPC~sendCallback Response handler function Source: lib/rpc.js, line 155 Type Definitions closeCallback() This callback is called upon completion of RPC#open Source: lib/rpc.js, line 144 openCallback() This callback is called upon completion of RPC#open Source: lib/rpc.js, line 119 sendCallback(err, message) This callback is called upon receipt of a response from RPC#send Parameters: Name Type Description err Error The error object, if any message Message The received response Message Source: lib/rpc.js, line 192 Events CONTACT_SEEN Triggered when a contact is seen Parameters: Name Type Description contact Contact The contact that was just encountered Source: lib/rpc.js, line 47 FIND_NODE Triggered when a FIND_NODE RPC is received Parameters: Name Type Description message Message The message received Source: lib/rpc.js, line 60 FIND_VALUE Triggered when a FIND_VALUE RPC message is received Parameters: Name Type Description message Message The message received Source: lib/rpc.js, line 66 MESSAGE_DROP Triggered when an invalid RPC message is dropped Parameters: Name Type Description message Buffer The raw invalid message received Source: lib/rpc.js, line 84 PING Triggered when a PING RPC message is received Parameters: Name Type Description message Message The message received Source: lib/rpc.js, line 72 ready Triggered when the underlying transport is open Source: lib/rpc.js, line 42 STORE Triggered when a STORE RPC message is received Parameters: Name Type Description message Message The message received Source: lib/rpc.js, line 78 TIMEOUT Triggered when a RPC message times out Parameters: Name Type Description contact Contact The contact that did not respond message Message The message sent that timed out Source: lib/rpc.js, line 53 × Search results Close Documentation generated by JSDoc 3.4.3 using the DocStrap template. "},"TCPTransport.html":{"id":"TCPTransport.html","title":"Class: TCPTransport","body":" KadTools Modules kadkad/constantskad/contactskad/hookskad/storagekad/transportskad/utils Classes AddressPortContactBucketContactHTTPTransportItemLoggerMessagekad/storage.FSkad/storage.LocalStoragekad/storage.MemStoreNodeRouterRPCTCPTransportUDPTransport Events HTTPTransport#event:CONTACT_SEENHTTPTransport#event:FIND_NODEHTTPTransport#event:FIND_VALUEHTTPTransport#event:MESSAGE_DROPHTTPTransport#event:PINGHTTPTransport#event:readyHTTPTransport#event:STOREHTTPTransport#event:TIMEOUTNode#event:connectNode#event:disconnectNode#event:errorNode#event:joinNode#event:leaveRouter#event:addRouter#event:dropRouter#event:shiftRPC#event:CONTACT_SEENRPC#event:FIND_NODERPC#event:FIND_VALUERPC#event:MESSAGE_DROPRPC#event:PINGRPC#event:readyRPC#event:STORERPC#event:TIMEOUTTCPTransport#event:CONTACT_SEENTCPTransport#event:FIND_NODETCPTransport#event:FIND_VALUETCPTransport#event:MESSAGE_DROPTCPTransport#event:PINGTCPTransport#event:readyTCPTransport#event:STORETCPTransport#event:TIMEOUTUDPTransport#event:CONTACT_SEENUDPTransport#event:FIND_NODEUDPTransport#event:FIND_VALUEUDPTransport#event:MESSAGE_DROPUDPTransport#event:PINGUDPTransport#event:readyUDPTransport#event:STOREUDPTransport#event:TIMEOUT Tutorials Custom ContactsCustom Storage AdaptersCustom Transport AdaptersProtocol SpecificationUsing Hooks Externals kad-fskad-localstoragekad-memstore Class: TCPTransport TCPTransport new TCPTransport(contact) Transport adapter that sends and receives messages over a TCP socket Parameters: Name Type Description contact AddressPortContact Your node's Contact instance Source: lib/transports/tcp.js, line 16 Extends RPC Methods after(event, handler) Registers an &quot;after&quot; hook Parameters: Name Type Description event String Name of the event to catch handler function Event handler to register Inherited From: RPC#after Source: lib/rpc.js, line 258 before(event, handler) Registers a &quot;before&quot; hook Parameters: Name Type Description event String Name of the event to catch handler function Event handler to register Inherited From: RPC#before Source: lib/rpc.js, line 249 close(callback) Closes the underlying transport Parameters: Name Type Description callback RPC~closeCallback Called when the transport is closed Inherited From: RPC#close Source: lib/rpc.js, line 128 open(callback) Opens the underlying transport Parameters: Name Type Description callback RPC~openCallback Called when the transport is opened Inherited From: RPC#open Source: lib/rpc.js, line 97 Fires: RPC#event:ready receive(buffer) Handle incoming messages Parameters: Name Type Description buffer Buffer Raw binary data to be processed by the RPC handler Inherited From: RPC#receive Source: lib/rpc.js, line 203 send(contact, message, callback) Send a RPC to the given contact Parameters: Name Type Description contact Contact Delivery target for message message Message Message to send to target callback RPC~sendCallback Response handler function Inherited From: RPC#send Source: lib/rpc.js, line 155 Events CONTACT_SEEN Triggered when a contact is seen Parameters: Name Type Description contact Contact The contact that was just encountered Inherited From: RPC#event:CONTACT_SEEN Source: lib/rpc.js, line 47 FIND_NODE Triggered when a FIND_NODE RPC is received Parameters: Name Type Description message Message The message received Inherited From: RPC#event:FIND_NODE Source: lib/rpc.js, line 60 FIND_VALUE Triggered when a FIND_VALUE RPC message is received Parameters: Name Type Description message Message The message received Inherited From: RPC#event:FIND_VALUE Source: lib/rpc.js, line 66 MESSAGE_DROP Triggered when an invalid RPC message is dropped Parameters: Name Type Description message Buffer The raw invalid message received Inherited From: RPC#event:MESSAGE_DROP Source: lib/rpc.js, line 84 PING Triggered when a PING RPC message is received Parameters: Name Type Description message Message The message received Inherited From: RPC#event:PING Source: lib/rpc.js, line 72 ready Triggered when the underlying transport is open Inherited From: RPC#event:ready Source: lib/rpc.js, line 42 STORE Triggered when a STORE RPC message is received Parameters: Name Type Description message Message The message received Inherited From: RPC#event:STORE Source: lib/rpc.js, line 78 TIMEOUT Triggered when a RPC message times out Parameters: Name Type Description contact Contact The contact that did not respond message Message The message sent that timed out Inherited From: RPC#event:TIMEOUT Source: lib/rpc.js, line 53 × Search results Close Documentation generated by JSDoc 3.4.3 using the DocStrap template. "},"UDPTransport.html":{"id":"UDPTransport.html","title":"Class: UDPTransport","body":" KadTools Modules kadkad/constantskad/contactskad/hookskad/storagekad/transportskad/utils Classes AddressPortContactBucketContactHTTPTransportItemLoggerMessagekad/storage.FSkad/storage.LocalStoragekad/storage.MemStoreNodeRouterRPCTCPTransportUDPTransport Events HTTPTransport#event:CONTACT_SEENHTTPTransport#event:FIND_NODEHTTPTransport#event:FIND_VALUEHTTPTransport#event:MESSAGE_DROPHTTPTransport#event:PINGHTTPTransport#event:readyHTTPTransport#event:STOREHTTPTransport#event:TIMEOUTNode#event:connectNode#event:disconnectNode#event:errorNode#event:joinNode#event:leaveRouter#event:addRouter#event:dropRouter#event:shiftRPC#event:CONTACT_SEENRPC#event:FIND_NODERPC#event:FIND_VALUERPC#event:MESSAGE_DROPRPC#event:PINGRPC#event:readyRPC#event:STORERPC#event:TIMEOUTTCPTransport#event:CONTACT_SEENTCPTransport#event:FIND_NODETCPTransport#event:FIND_VALUETCPTransport#event:MESSAGE_DROPTCPTransport#event:PINGTCPTransport#event:readyTCPTransport#event:STORETCPTransport#event:TIMEOUTUDPTransport#event:CONTACT_SEENUDPTransport#event:FIND_NODEUDPTransport#event:FIND_VALUEUDPTransport#event:MESSAGE_DROPUDPTransport#event:PINGUDPTransport#event:readyUDPTransport#event:STOREUDPTransport#event:TIMEOUT Tutorials Custom ContactsCustom Storage AdaptersCustom Transport AdaptersProtocol SpecificationUsing Hooks Externals kad-fskad-localstoragekad-memstore Class: UDPTransport UDPTransport new UDPTransport(contact) Transport adapter that sends and receives message over UDP Parameters: Name Type Description contact Contact Your node's Contact instance Source: lib/transports/udp.js, line 15 Extends RPC Methods after(event, handler) Registers an &quot;after&quot; hook Parameters: Name Type Description event String Name of the event to catch handler function Event handler to register Inherited From: RPC#after Source: lib/rpc.js, line 258 before(event, handler) Registers a &quot;before&quot; hook Parameters: Name Type Description event String Name of the event to catch handler function Event handler to register Inherited From: RPC#before Source: lib/rpc.js, line 249 close(callback) Closes the underlying transport Parameters: Name Type Description callback RPC~closeCallback Called when the transport is closed Inherited From: RPC#close Source: lib/rpc.js, line 128 open(callback) Opens the underlying transport Parameters: Name Type Description callback RPC~openCallback Called when the transport is opened Inherited From: RPC#open Source: lib/rpc.js, line 97 Fires: RPC#event:ready receive(buffer) Handle incoming messages Parameters: Name Type Description buffer Buffer Raw binary data to be processed by the RPC handler Inherited From: RPC#receive Source: lib/rpc.js, line 203 send(contact, message, callback) Send a RPC to the given contact Parameters: Name Type Description contact Contact Delivery target for message message Message Message to send to target callback RPC~sendCallback Response handler function Inherited From: RPC#send Source: lib/rpc.js, line 155 Events CONTACT_SEEN Triggered when a contact is seen Parameters: Name Type Description contact Contact The contact that was just encountered Inherited From: RPC#event:CONTACT_SEEN Source: lib/rpc.js, line 47 FIND_NODE Triggered when a FIND_NODE RPC is received Parameters: Name Type Description message Message The message received Inherited From: RPC#event:FIND_NODE Source: lib/rpc.js, line 60 FIND_VALUE Triggered when a FIND_VALUE RPC message is received Parameters: Name Type Description message Message The message received Inherited From: RPC#event:FIND_VALUE Source: lib/rpc.js, line 66 MESSAGE_DROP Triggered when an invalid RPC message is dropped Parameters: Name Type Description message Buffer The raw invalid message received Inherited From: RPC#event:MESSAGE_DROP Source: lib/rpc.js, line 84 PING Triggered when a PING RPC message is received Parameters: Name Type Description message Message The message received Inherited From: RPC#event:PING Source: lib/rpc.js, line 72 ready Triggered when the underlying transport is open Inherited From: RPC#event:ready Source: lib/rpc.js, line 42 STORE Triggered when a STORE RPC message is received Parameters: Name Type Description message Message The message received Inherited From: RPC#event:STORE Source: lib/rpc.js, line 78 TIMEOUT Triggered when a RPC message times out Parameters: Name Type Description contact Contact The contact that did not respond message Message The message sent that timed out Inherited From: RPC#event:TIMEOUT Source: lib/rpc.js, line 53 × Search results Close Documentation generated by JSDoc 3.4.3 using the DocStrap template. "},"tutorial-custom-contacts.html":{"id":"tutorial-custom-contacts.html","title":"Tutorial: Custom Contacts","body":" KadTools Modules kadkad/constantskad/contactskad/hookskad/storagekad/transportskad/utils Classes AddressPortContactBucketContactHTTPTransportItemLoggerMessagekad/storage.FSkad/storage.LocalStoragekad/storage.MemStoreNodeRouterRPCTCPTransportUDPTransport Events HTTPTransport#event:CONTACT_SEENHTTPTransport#event:FIND_NODEHTTPTransport#event:FIND_VALUEHTTPTransport#event:MESSAGE_DROPHTTPTransport#event:PINGHTTPTransport#event:readyHTTPTransport#event:STOREHTTPTransport#event:TIMEOUTNode#event:connectNode#event:disconnectNode#event:errorNode#event:joinNode#event:leaveRouter#event:addRouter#event:dropRouter#event:shiftRPC#event:CONTACT_SEENRPC#event:FIND_NODERPC#event:FIND_VALUERPC#event:MESSAGE_DROPRPC#event:PINGRPC#event:readyRPC#event:STORERPC#event:TIMEOUTTCPTransport#event:CONTACT_SEENTCPTransport#event:FIND_NODETCPTransport#event:FIND_VALUETCPTransport#event:MESSAGE_DROPTCPTransport#event:PINGTCPTransport#event:readyTCPTransport#event:STORETCPTransport#event:TIMEOUTUDPTransport#event:CONTACT_SEENUDPTransport#event:FIND_NODEUDPTransport#event:FIND_VALUEUDPTransport#event:MESSAGE_DROPUDPTransport#event:PINGUDPTransport#event:readyUDPTransport#event:STOREUDPTransport#event:TIMEOUT Tutorials Custom ContactsCustom Storage AdaptersCustom Transport AdaptersProtocol SpecificationUsing Hooks Externals kad-fskad-localstoragekad-memstore Custom Contacts Creating a custom contact is very simple. You need only to: Define a constructor function that accepts a dictionary Inherit from Contact Implement Contact#_createNodeID Call super class at bottom of your constructor Example: Address/Port Contactvar kademlia = require('kad'); var inherits = require('util').inherits; var utils = require('../utils'); // Define you constructor function function AddressPortContact(options) { // Make sure the `new` keyword is not required if (!(this instanceof AddressPortContact)) { return new AddressPortContact(options); } // Store relevant contact information this.address = options.address; this.port = options.port; // Call super class to setup bindings kademlia.Contact.call(this, options); } // Inherit from `kademlia.Contact` inherits(AddressPortContact, kademlia.Contact); // Implement `_createNodeID` for super class to use AddressPortContact.prototype._createNodeID = function() { return utils.createID(this.address + ':' + this.port); }; × Search results Close Documentation generated by JSDoc 3.4.3 using the DocStrap template. "},"tutorial-custom-storage.html":{"id":"tutorial-custom-storage.html","title":"Tutorial: Custom Storage Adapters","body":" KadTools Modules kadkad/constantskad/contactskad/hookskad/storagekad/transportskad/utils Classes AddressPortContactBucketContactHTTPTransportItemLoggerMessagekad/storage.FSkad/storage.LocalStoragekad/storage.MemStoreNodeRouterRPCTCPTransportUDPTransport Events HTTPTransport#event:CONTACT_SEENHTTPTransport#event:FIND_NODEHTTPTransport#event:FIND_VALUEHTTPTransport#event:MESSAGE_DROPHTTPTransport#event:PINGHTTPTransport#event:readyHTTPTransport#event:STOREHTTPTransport#event:TIMEOUTNode#event:connectNode#event:disconnectNode#event:errorNode#event:joinNode#event:leaveRouter#event:addRouter#event:dropRouter#event:shiftRPC#event:CONTACT_SEENRPC#event:FIND_NODERPC#event:FIND_VALUERPC#event:MESSAGE_DROPRPC#event:PINGRPC#event:readyRPC#event:STORERPC#event:TIMEOUTTCPTransport#event:CONTACT_SEENTCPTransport#event:FIND_NODETCPTransport#event:FIND_VALUETCPTransport#event:MESSAGE_DROPTCPTransport#event:PINGTCPTransport#event:readyTCPTransport#event:STORETCPTransport#event:TIMEOUTUDPTransport#event:CONTACT_SEENUDPTransport#event:FIND_NODEUDPTransport#event:FIND_VALUEUDPTransport#event:MESSAGE_DROPUDPTransport#event:PINGUDPTransport#event:readyUDPTransport#event:STOREUDPTransport#event:TIMEOUT Tutorials Custom ContactsCustom Storage AdaptersCustom Transport AdaptersProtocol SpecificationUsing Hooks Externals kad-fskad-localstoragekad-memstore Custom Storage Adapters Creating a storage a adapter for use with Kad is very simple. A storage adapter is an object with 4 public methods: get(key, callback) put(key, value, callback) del(key, callback) createReadStream() The get() and put() methods are used for handling STORE and FIND_VALUE messages. The del() method is for handling item expiration. The createReadStream() method is used for periodic replication. Values are serialized to a String before being passed to your storage adapter and a String is expected to be returned when an item is requested. Callbacks should be called with (err[, result]) always. The createReadStream() method should return a stream.Readable with objectMode enabled and emit data event for every item stored until all of the stored items have been enumerated. The data event should include an object with the following format: { key: '&lt;item_key&gt;', value: '&lt;json_serialized_item_object&gt;' } × Search results Close Documentation generated by JSDoc 3.4.3 using the DocStrap template. "},"tutorial-custom-transports.html":{"id":"tutorial-custom-transports.html","title":"Tutorial: Custom Transport Adapters","body":" KadTools Modules kadkad/constantskad/contactskad/hookskad/storagekad/transportskad/utils Classes AddressPortContactBucketContactHTTPTransportItemLoggerMessagekad/storage.FSkad/storage.LocalStoragekad/storage.MemStoreNodeRouterRPCTCPTransportUDPTransport Events HTTPTransport#event:CONTACT_SEENHTTPTransport#event:FIND_NODEHTTPTransport#event:FIND_VALUEHTTPTransport#event:MESSAGE_DROPHTTPTransport#event:PINGHTTPTransport#event:readyHTTPTransport#event:STOREHTTPTransport#event:TIMEOUTNode#event:connectNode#event:disconnectNode#event:errorNode#event:joinNode#event:leaveRouter#event:addRouter#event:dropRouter#event:shiftRPC#event:CONTACT_SEENRPC#event:FIND_NODERPC#event:FIND_VALUERPC#event:MESSAGE_DROPRPC#event:PINGRPC#event:readyRPC#event:STORERPC#event:TIMEOUTTCPTransport#event:CONTACT_SEENTCPTransport#event:FIND_NODETCPTransport#event:FIND_VALUETCPTransport#event:MESSAGE_DROPTCPTransport#event:PINGTCPTransport#event:readyTCPTransport#event:STORETCPTransport#event:TIMEOUTUDPTransport#event:CONTACT_SEENUDPTransport#event:FIND_NODEUDPTransport#event:FIND_VALUEUDPTransport#event:MESSAGE_DROPUDPTransport#event:PINGUDPTransport#event:readyUDPTransport#event:STOREUDPTransport#event:TIMEOUT Tutorials Custom ContactsCustom Storage AdaptersCustom Transport AdaptersProtocol SpecificationUsing Hooks Externals kad-fskad-localstoragekad-memstore Custom Transport Adapters The primary focus for Kad's design was to create a simple, sane, minimally configured setup while allowing for maximum flexibility when it comes to building applications on or around it. This is why all of the communication logic is abstracted. Kad does not care how your nodes talk to one another, you simply provide it with the information that your transport adapter needs to communicate with peers and it will handle the rest. When building a custom transport, there are a few simple steps: Implement a custom Contact Inherit your transport from RPC Implement _open, _send, and _close methods A Contact contains the information your transport adapter needs to talk to other peers. A Transport defines how those peers communicate. Example: Simple UDP Transportvar kademlia = require('kademlia'); var inherits = require('util').inherits; var dgram = require('dgram'); // Define your Transport as a constructor function function UDPTransport(contact, options) { var self = this; // Make sure that it can be instantiated without the `new` keyword if (!(this instanceof UDPTransport)) { return new UDPTransport(contact, options); } // Call `kademlia.RPC` to setup bindings kademlia.RPC.call(this, contact, options); } // Inherit for `kademlia.RPC` inherits(UDPTransport, kademlia.RPC); // Implement `_open` method to start server UDPTransport.prototype._open = function(ready) { // Create a UDP socket object this._socket = dgram.createSocket({ type: 'udp4', reuseAddr: true }, function(messageBuffer) { // Call RPC.receive when ready for Kad to handle message self.receive(messageBuffer); }); // Start listening for UDP messages on the supplied address and port this._socket.bind(contact.port, contact.address, ready); }; // Implement `_send` method to deliver a message UDPTransport.prototype._send = function(data, contact) { this._socket.send(data, 0, data.length, contact.port, contact.address); }; // Implement `_close` method to cleanup UDPTransport.prototype._close = function() { this._socket.close(); }; × Search results Close Documentation generated by JSDoc 3.4.3 using the DocStrap template. "},"tutorial-protocol-spec.html":{"id":"tutorial-protocol-spec.html","title":"Tutorial: Protocol Specification","body":" KadTools Modules kadkad/constantskad/contactskad/hookskad/storagekad/transportskad/utils Classes AddressPortContactBucketContactHTTPTransportItemLoggerMessagekad/storage.FSkad/storage.LocalStoragekad/storage.MemStoreNodeRouterRPCTCPTransportUDPTransport Events HTTPTransport#event:CONTACT_SEENHTTPTransport#event:FIND_NODEHTTPTransport#event:FIND_VALUEHTTPTransport#event:MESSAGE_DROPHTTPTransport#event:PINGHTTPTransport#event:readyHTTPTransport#event:STOREHTTPTransport#event:TIMEOUTNode#event:connectNode#event:disconnectNode#event:errorNode#event:joinNode#event:leaveRouter#event:addRouter#event:dropRouter#event:shiftRPC#event:CONTACT_SEENRPC#event:FIND_NODERPC#event:FIND_VALUERPC#event:MESSAGE_DROPRPC#event:PINGRPC#event:readyRPC#event:STORERPC#event:TIMEOUTTCPTransport#event:CONTACT_SEENTCPTransport#event:FIND_NODETCPTransport#event:FIND_VALUETCPTransport#event:MESSAGE_DROPTCPTransport#event:PINGTCPTransport#event:readyTCPTransport#event:STORETCPTransport#event:TIMEOUTUDPTransport#event:CONTACT_SEENUDPTransport#event:FIND_NODEUDPTransport#event:FIND_VALUEUDPTransport#event:MESSAGE_DROPUDPTransport#event:PINGUDPTransport#event:readyUDPTransport#event:STOREUDPTransport#event:TIMEOUT Tutorials Custom ContactsCustom Storage AdaptersCustom Transport AdaptersProtocol SpecificationUsing Hooks Externals kad-fskad-localstoragekad-memstore Protocol Specification PINGRequest: { &quot;method&quot;: &quot;PING&quot;, &quot;params&quot;: { &quot;contact&quot;: { &quot;address&quot;: &quot;&lt;net_addr&gt;&quot;, &quot;port&quot;: 1234, &quot;nodeID&quot;: &quot;&lt;node_id&gt;&quot; } }, &quot;id&quot;: &quot;&lt;rpc_id&gt;&quot; }Response: { &quot;result&quot;: { &quot;contact&quot;: { &quot;address&quot;: &quot;&lt;net_addr&gt;&quot;, &quot;port&quot;: 1234, &quot;nodeID&quot;: &quot;&lt;node_id&gt;&quot; } }, &quot;id&quot;: &quot;&lt;rpc_id&gt;&quot; }STORERequest: { &quot;method&quot;: &quot;STORE&quot;, &quot;params&quot;: { &quot;item&quot;: { &quot;key&quot;: &quot;&lt;key&gt;&quot;, &quot;value&quot;: &quot;&lt;value&gt;&quot;, &quot;timestamp&quot;: 1450715749709, &quot;publisher&quot;: &quot;&lt;node_id&gt;&quot; }, &quot;contact&quot;: { &quot;address&quot;: &quot;&lt;net_addr&gt;&quot;, &quot;port&quot;: 1234, &quot;nodeID&quot;: &quot;&lt;node_id&gt;&quot; } }, &quot;id&quot;: &quot;&lt;rpc_id&gt;&quot; }Response: { &quot;result&quot;: { &quot;contact&quot;: { &quot;address&quot;: &quot;&lt;net_addr&gt;&quot;, &quot;port&quot;: 1234, &quot;nodeID&quot;: &quot;&lt;node_id&gt;&quot; } }, &quot;id&quot;: &quot;&lt;rpc_id&gt;&quot; }FIND_NODERequest: { &quot;method&quot;: &quot;FIND_NODE&quot;, &quot;params&quot;: { &quot;key&quot;: &quot;&lt;key&gt;&quot;, &quot;contact&quot;: { &quot;address&quot;: &quot;&lt;net_addr&gt;&quot;, &quot;port&quot;: 1234, &quot;nodeID&quot;: &quot;&lt;node_id&gt;&quot; } }, &quot;id&quot;: &quot;&lt;rpc_id&gt;&quot; }Response: { &quot;result&quot;: { &quot;nodes&quot;: [ { &quot;address&quot;: &quot;&lt;net_addr&gt;&quot;, &quot;port&quot;: 1234, &quot;nodeID&quot;: &quot;&lt;node_id&gt;&quot; }, { &quot;address&quot;: &quot;&lt;net_addr&gt;&quot;, &quot;port&quot;: 1234, &quot;nodeID&quot;: &quot;&lt;node_id&gt;&quot; }, { &quot;address&quot;: &quot;&lt;net_addr&gt;&quot;, &quot;port&quot;: 1234, &quot;nodeID&quot;: &quot;&lt;node_id&gt;&quot; } ], &quot;contact&quot;: { &quot;address&quot;: &quot;&lt;net_addr&gt;&quot;, &quot;port&quot;: 1234, &quot;nodeID&quot;: &quot;&lt;node_id&gt;&quot; } }, &quot;id&quot;: &quot;&lt;rpc_id&gt;&quot; }FIND_VALUERequest: { &quot;method&quot;: &quot;FIND_VALUE&quot;, &quot;params&quot;: { &quot;key&quot;: &quot;&lt;key&gt;&quot;, &quot;contact&quot;: { &quot;address&quot;: &quot;&lt;net_addr&gt;&quot;, &quot;port&quot;: 1234, &quot;nodeID&quot;: &quot;&lt;node_id&gt;&quot; } }, &quot;id&quot;: &quot;&lt;rpc_id&gt;&quot; }Response: { &quot;result&quot;: { &quot;item&quot;: { &quot;key&quot;: &quot;&lt;key&gt;&quot;, &quot;value&quot;: &quot;&lt;value&gt;&quot;, &quot;timestamp&quot;: 1450715749709, &quot;publisher&quot;: &quot;&lt;node_id&gt;&quot; }, &quot;contact&quot;: { &quot;address&quot;: &quot;&lt;net_addr&gt;&quot;, &quot;port&quot;: 1234, &quot;nodeID&quot;: &quot;&lt;node_id&gt;&quot; } }, &quot;id&quot;: &quot;&lt;rpc_id&gt;&quot; }ERROR{ &quot;result&quot;: { &quot;contact&quot;: { &quot;address&quot;: &quot;&lt;net_addr&gt;&quot;, &quot;port&quot;: 1234, &quot;nodeID&quot;: &quot;&lt;node_id&gt;&quot; } }, &quot;error&quot;: { &quot;code&quot;: -32603, &quot;message&quot;: &quot;&lt;error_message&gt;&quot; }, &quot;id&quot;: &quot;&lt;rpc_id&gt;&quot; } × Search results Close Documentation generated by JSDoc 3.4.3 using the DocStrap template. "},"tutorial-using-hooks.html":{"id":"tutorial-using-hooks.html","title":"Tutorial: Using Hooks","body":" KadTools Modules kadkad/constantskad/contactskad/hookskad/storagekad/transportskad/utils Classes AddressPortContactBucketContactHTTPTransportItemLoggerMessagekad/storage.FSkad/storage.LocalStoragekad/storage.MemStoreNodeRouterRPCTCPTransportUDPTransport Events HTTPTransport#event:CONTACT_SEENHTTPTransport#event:FIND_NODEHTTPTransport#event:FIND_VALUEHTTPTransport#event:MESSAGE_DROPHTTPTransport#event:PINGHTTPTransport#event:readyHTTPTransport#event:STOREHTTPTransport#event:TIMEOUTNode#event:connectNode#event:disconnectNode#event:errorNode#event:joinNode#event:leaveRouter#event:addRouter#event:dropRouter#event:shiftRPC#event:CONTACT_SEENRPC#event:FIND_NODERPC#event:FIND_VALUERPC#event:MESSAGE_DROPRPC#event:PINGRPC#event:readyRPC#event:STORERPC#event:TIMEOUTTCPTransport#event:CONTACT_SEENTCPTransport#event:FIND_NODETCPTransport#event:FIND_VALUETCPTransport#event:MESSAGE_DROPTCPTransport#event:PINGTCPTransport#event:readyTCPTransport#event:STORETCPTransport#event:TIMEOUTUDPTransport#event:CONTACT_SEENUDPTransport#event:FIND_NODEUDPTransport#event:FIND_VALUEUDPTransport#event:MESSAGE_DROPUDPTransport#event:PINGUDPTransport#event:readyUDPTransport#event:STOREUDPTransport#event:TIMEOUT Tutorials Custom ContactsCustom Storage AdaptersCustom Transport AdaptersProtocol SpecificationUsing Hooks Externals kad-fskad-localstoragekad-memstore Using Hooks The kademlia.RPC class exposes a hooks interface for processing messages and implementing custom behaviors. Hooks are executed in the order they are registered. Calling next(err) will exit the middleware stack and prevent Kad from handling the message. You should always define an error handler, otherwise RPC will throw. EventsThe kademlia.RPC class triggers hooks for the following events: serialize before handler receives (message, next) after handler receives nothing deserialize before handler receives (buffer, next) after handler receives nothing send before handler receives (buffer, contact, next) after handler receives nothing receive before handler receives (message, contact, next) after handler receives nothing open before handler receives (next) after handler receives nothing close before handler receives (next) after handler receives nothing Example: Simple Blacklist Hook// array of blacklisted nodeID's var blacklist = []; // use a logger to print when a blacklisted node talks var logger = kademlia.Logger(3); // the transport adapter we will pass to our `Node` var transport = kademlia.transports.UDP(contact, options); // register a middleware function to check blacklist transport.before('receive', function(message, contact, next) { // exit middleware stack if contact is blacklisted if (blacklist.indexOf(contact.nodeID) !== -1) { return next(new Error('Message dropped from blacklisted contact')); } // otherwise pass on next(); }); // handle errors from RPC transport.on('error', function(err) { logger.warn('RPC error raised, reason: %s', err.message); });Request/Response HandlingThe middleware stack gets applied to both requests and responses. If you need your middleware to only apply to one or the other, use the Message module to check the type of message: var Message = kademlia.Message; // only apply this middleware to requests transport.before('receive', function(message, contact, next) { // return early and move to next middleware if this is not a request if (!Message.isRequest(message)) { return next(); } // otherwise do fancy middleware stuff ... }); × Search results Close Documentation generated by JSDoc 3.4.3 using the DocStrap template. "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
